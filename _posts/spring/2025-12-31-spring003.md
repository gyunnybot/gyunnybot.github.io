---
layout: single
title:  "의존 역전"
folder: "spring"
categories:
  - spring
permalink: categories/spring/3
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 컨트롤러는 왜 저수준 컴포넌트일까?
레이어드 아키텍처를 공부하거나 스프링 프로젝트를 설계하다 보면, \'컨트롤러는 저수준 컴포넌트다\'라는 말을 자주 마주친다. 처음에는 이 표현이 낯설게 느껴지는데, 이는 컨트롤러는 사용자 요청을 가장 먼저 받는 핵심 진입점처럼 보이기 때문이다. 하지만 고수준/저수준을 가르는 요소는 중요도나 위계가 아니라 변경 이유와 의존성 방향을 기준으로 나뉜다. 해당 관점으로 보면 컨트롤러가 저수준이고 서비스, 레포지토리 인터페이스가 고수준이라는 말이 훨씬 명확해진다.

먼저 컨트롤러는 애플리케이션의 \'바깥\'에 붙어 있으면서 HTTP 메서드, URL, 헤더, 쿼리스트링, 상태코드, 응답 포맷(JSON/HTML), 인증 방식 같은 것들과 강하게 결합된다. 즉 컨트롤러는 비즈니스 규칙 그 자체가 아니라, 비즈니스 규칙에 들어오고 나가는 \'전달 방식(전송 규약)\'을 다루는 어댑터라고 볼 수 있다. 전달 방식은 생각보다 자주 바뀐다. REST에서 GraphQL로 전환하거나, 프론트 요구로 응답 DTO가 바뀌거나, API 스펙이 개편되거나, 인증 헤더 규칙이 바뀌는 순간 컨트롤러는 즉시 수정 대상이 된다. 이처럼 컨트롤러는 핵심 정책보다 \'외부 환경\'에 의해 흔들리기 쉬운 가장자리이므로 아키텍처 관점에서 저수준(세부사항)으로 분류되는 것이다.

반대로 서비스(특히 Application Service/UseCase)는 \'무엇을 할지\'를 결정한다. 회원가입을 예로 들면, 중복 이메일 체크 -> 비밀번호 암호화 -> 저장 -> 후처리 같은 업무 흐름(정책)을 서비스가 정의한다. 여기서 중요한 점은, HTTP의 형태가 바뀌어도(컨트롤러 변경) \'회원가입 유스케이스\' 자체는 보통 그대로라는 것이다. DB를 MySQL에서 다른 저장소로 바꾸더라도(레포 구현 변경) 회원가입에 필요한 규칙과 순서는 서비스에 남는다. 즉 서비스는 외부 기술 변화보다 도메인 요구사항 변화에 따라 변한다. 그래서 서비스는 핵심에 가까운, 즉 고수준(정책) 컴포넌트로 본다. 서비스가 repository를 호출하더라도, 호출 순서와 규칙을 결정하는 주도권은 서비스가 쥐고 있다. 저수준을 사용하지만 지배하는 쪽이 고수준이다.

그렇다면 레포지토리 레이어는 어떨까? 많은 사람들이 repository를 DB 접근으로 떠올리며 저수준이라 생각한다. 여기서 중요한 구분이 하나 있다. Repository 구현체와 Repository 인터페이스는 레벨이 다르다. JPA, QueryDSL, JDBC Template과 같은 구현체는 어떻게 저장하고 조회할지 결정하는 분명한 세부사항이다. 하지만 \'저장소가 이런 기능을 제공해야 한다\'는 인터페이스(추상/계약) 자체는 유스케이스가 필요로 하는 요구를 표현한다.

예를 들어 save, findById, existsByEmail 같은 시그니처는 \'DB를 어떤 라이브러리로 붙일지\'가 아니라 \'유스케이스가 데이터를 이런 방식으로 쓰고 싶다\'는 뜻에 가깝다. 그래서 의존성 역전 원칙(DIP) 관점에서는, 고수준인 서비스가 저수준인 DB 기술에 직접 의존하지 않도록 서비스가 추상(Repository interface)에 의존하고, 실제 DB 접근은 구현체가 추상을 구현하며 따라오게 만든다.

\'추상은 안쪽에서 정의되고, 구현은 바깥에서 맞춘다\'는 원칙이 바로 이 지점에서 작동한다. 그래서 repository interface는 고수준(정책 측의 요구/포트)이고, repository implementation은 저수준(기술/어댑터)이 된다.

## 고수준/저수준 컴포넌트 정리
정리하면, 컨트롤러는 HTTP라는 바깥 규약에 묶인 입출력 어댑터라 저수준이고, 서비스는 유스케이스 흐름을 결정하는 정책이라 고수준이며, 레포지토리 인터페이스는 유스케이스가 필요로 하는 저장소 \'계약\'으로 판단되어 고수준이다. 반면에 JPA 기반 레포 구현체는 그 계약을 DB 기술로 만족시키는 세부사항이므로 저수준이다. 결국 고수준/저수준은 \'누가 누구를 호출하느냐\'보다 \'무엇이 무엇에 의해 바뀌느냐\', \'정책이 세부사항을 지배하도록 의존성 방향이 잡혀 있느냐\'로 판단하는 개념이다.

이 기준을 실제 코드로 가져오면 실용적인 설계 규칙도 자연스럽게 나온다. 컨트롤러는 요청을 받아 DTO로 파싱하고, 최소한의 검증을 하고, 서비스에 필요한 입력 형태로 변환해서 호출하고, 결과를 응답 형태로 매핑해 반환하는 선에서 멈추는 게 좋다. 업무 규칙을 컨트롤러가 들기 시작하면, HTTP 스펙 변경이 곧 비즈니스 로직 변경으로 번지고 테스트도 어려워진다.

서비스는 유스케이스를 읽기 좋은 절차로 조직하고, 트랜잭션 경계를 관리하며, 도메인 객체와 레포지토리(추상)를 엮어 정책을 실행한다. 레포지토리 인터페이스는 서비스/도메인이 필요한 만큼만 정의하고, 구현체는 기술 선택(JPA/QueryDSL/SQL)이 바뀌어도 정책을 건드리지 않도록 바깥에서 교체 가능하게 둔다. 이 구조가 유지되면, UI/전송/저장 방식이 바뀌는 변화는 바깥 레이어에서 흡수되고, 업무 규칙 변화는 안쪽에서 다루게 된다. 변경의 파도가 핵심을 직접 때리지 않도록 방파제를 두는 셈이다.

컨트롤러를 저수준이라 부르는 것은 컨트롤러가 덜 중요해서가 아니다. 오히려 중요한 역할(입출력)을 맡는다. 다만 그 역할의 본질이 정책이 아닌 세부사항에 가깝다는 뜻이다. 반대로 서비스와 레포지토리 인터페이스를 고수준이라 부르는 것은 기술적으로 화려해서가 아니라, 도메인의 의도를 가장 잘 반영하는 곳이기 때문이다. 결국 좋은 설계는 \'핵심 규칙이 바깥 기술에 휘둘리지 않도록\' 의존성을 정리하는 데서 시작한다.