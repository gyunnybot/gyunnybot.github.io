---
layout: single
title:  "Bean Validation 검증 흐름"
folder: "spring"
categories:
  - spring
permalink: categories/spring/2
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 왜 @RestController에는 @Validated가 필요없을까?
@Service가 붙은 클래스 내 메서드 파라미터는 @Valid를 활용한 유효성 검사를 진행하려면 반드시 @Validated 애노테이션을 클래스에 추가해야 하지만, @RestController는 @Validated를 붙여주지 않아도 @Valid를 붙인 매개변수의 검증이 잘 동작한다. 이 차이는 단순히 애노테이션 하나의 문제가 아니라, 검증이 실행되는 시점과 방식이 완전히 다르기 때문이다.

## 스프링에서 두 가지 검증 흐름
스프링에서 Bean Validation(@Valid, @NotNull, @Size 등)이 사용되는 전형적인 흐름은 크게 두 가지가 있다.

첫 번째는 웹 계층에서의 요청 파라미터 검증이다. @RestController 나 @Controller 의 메서드 파라미터에 @Valid 를 붙이는 방식으로, @RequestBody, @RequestParam, @PathVariable, @ModelAttribute 등에 붙은 @Valid 를 통해 HTTP 요청 데이터를 DTO로 바인딩하면서 동시에 검증까지 수행한다. 예를 들어 JSON 요청을 DTO로 변환할 때, 그 DTO에 선언된 검증 규칙을 함께 적용하는 것이다.

두 번째는 서비스 계층에서의 메서드 호출 검증이다. @Service 메서드의 인자나 반환값에 검증 애노테이션을 붙여두고, AOP 기반으로 메서드 호출 전/후를 가로채서 검사하는 방식이다. 다른 Bean이 memberService.join(dto)과 같은 메서드를 호출할 때, 그 인자와 리턴값에 대해 Bean Validation 규칙을 적용해 검증한다.

다시 말해 이 두 흐름은 사용하는 애노테이션 이름은 같지만, 실제로 동작하는 주체와 타이밍이 완전히 다르다.

## 컨트롤러에서의 @Valid: 스프링 MVC 요청 처리 중 자동 검증
컨트롤러에서 자주 보게 되는 코드는 다음과 같다.

```java
@RestController
public class MemberController {

    @PostMapping("/members")
    public void create(@RequestBody @Valid MemberRequest request) {
        // service.create(request) ... 이 시점에 이미 request는 검증이 끝난 상태
    }
}
```

이 경우 검증을 직접 수행하는 것은 컨트롤러 클래스가 아니라 스프링 MVC 인프라이다.

요청 흐름을 단순하게 풀어 쓰면 다음과 같다.

HTTP 요청이 들어오면 먼저 DispatcherServlet으로 진입하고, 어떤 컨트롤러 메서드를 호출할지 HandlerMapping을 통해 결정한다. 그 다음 이 메서드의 파라미터들을 만들기 위해 여러 HandlerMethodArgumentResolver가 호출되는데, 이 과정에서 @RequestBody, @ModelAttribute 같은 애노테이션이 해석된다.

파라미터에 @Valid 또는 @Validated가 붙어 있으면 WebDataBinder가 내부에 등록된 Validator(보통 Hibernate Validator)를 사용해 Bean Validation 검증을 수행한다. 검증에 실패하면 MethodArgumentNotValidException와 같은 예외가 발생하고, 이 예외는 기본 에러 핸들러나 @ControllerAdvice에 정의된 예외 처리 로직에 의해 400 응답 등으로 변환된다.

즉, 컨트롤러 메서드 자체가 호출되기 직전에 스프링 MVC가 \'메서드 파라미터를 생성하는 과정\'에서 @Valid 를 보고 자동으로 Bean Validation을 실행하는 구조다. 검증은 이미 HTTP 요청 -> 파라미터 바인딩 파이프라인 안에 녹아있는 것이다.

그래서 컨트롤러 클래스 자체에 @Validated를 굳이 붙이지 않아도 된다. 컨트롤러는 단지 검증을 거쳐 생성된 파라미터를 전달받아 사용하는 입장일 뿐이고, 검증 로직은 스프링 MVC 인프라가 책임지고 있다.

## 서비스에서의 @Valid: AOP 프록시 기반 메서드 검증
서비스 계층의 코드는 아래와 같이 작성할 수 있다.

```java
@Service
@Validated
public class MemberService {

    public void join(@Valid MemberDto dto) {
        // dto 검증 실패 시 메서드 진입 전 ConstraintViolationException 발생
    }

    public @NotNull MemberDto findMember(@NotNull Long id) {
        // id = null 이면 호출 시점에 예외
        // 반환값이 null이면 리턴 직후 예외
        return new MemberDto(...);
    }
}
```

MemberService가 원하는 것은 컨트롤러에서 HTTP 요청 바인딩과는 다르게 스프링 빈끼리 메서드를 호출할 때도 Bean Validation을 적용하는 것이다. 예를 들어 컨트롤러, 다른 서비스, 스케줄러 등이 memberService.join(dto) 나 memberService.findMember(id) 같은 메서드를 호출할 때, 인자와 반환값에 붙어 있는 검증 애노테이션을 통해 유효성을 검사하고 싶어지는 경우가 있다.

이 검증은 스프링 MVC의 파라미터 바인딩 과정과는 전혀 무관하며, \'스프링 빈의 메서드 호출\' 자체를 가로채서 처리해야 한다. 그래서 스프링은 AOP와 프록시를 활용하여 메서드 검증을 구현한다.

먼저 @Validated가 붙은 빈을 스프링이 스캔한다. 그런 다음 MethodValidationPostProcessor가 동작하면서 해당 빈을 감싸는 프록시 객체를 생성한다. 외부에서 memberService.join(dto)을 호출하면 실제 MemberService 인스턴스가 아니라, 이 프록시가 먼저 호출된다. 프록시는 메서드 인자와 리턴 타입에 붙어 있는 Bean Validation 애노테이션(@Valid, @NotNull, @Size 등)을 읽어 검증을 수행하고, 위반 사항이 있으면 ConstraintViolationException을 던진다.

핵심은 서비스 레이어에서 메서드 검증을 사용하려면 \'이 빈의 메서드 호출을 가로채서 검증하겠다\'라는 설정이 필요하고, 바로 그 역할을 클래스 레벨의 @Validated가 담당한다는 것이다. 따라서 @Service에서 메서드 검증을 쓰고 싶다면 @Validated를 함께 붙여야 한다. 그렇지 않으면 단순한 메서드 호출로만 처리되고, 검증은 일어나지 않는다.

## @RestController 와 @Service 의 차이 정리
@RestController에서 사용하는 @Valid는 HTTP 요청을 처리하는 과정, 구체적으로는 \'요청을 자바 객체 파라미터로 바인딩하는 과정\' 속에 검증 로직이 이미 포함되어 있다. 스프링 MVC가 컨트롤러 메서드를 호출하기 직전에 파라미터를 만들면서 검증까지 함께 수행한다. 따라서 컨트롤러 클래스에 @Validated를 따로 붙이지 않아도 Bean Validation이 잘 동작한다.

반면 @Service에서의 @Valid, @NotNull과 같은 애노테이션은 스프링 MVC와는 별도로 스프링 빈 메서드 호출 자체를 AOP 프록시로 가로채서 검증하는 기능을 사용한다. 이 기능을 활성화하는 트리거가 바로 @Validated이다. 이 애노테이션이 없으면 스프링이 해당 서비스 빈에 메서드 검증용 프록시를 만들지 않기 때문에, 검증 애노테이션을 붙여도 실제로는 아무 일이 일어나지 않는다.

결국 같은 Bean Validation 이라도 웹 계층과 서비스 계층에서 동작 방식과 실행 시점이 다르기 때문에, 한쪽에는 @Validated가 필요 없고 다른 쪽에는 필요한 것이다.