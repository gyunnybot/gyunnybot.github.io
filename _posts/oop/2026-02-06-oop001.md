---
layout: single
title:  "리스코프 치환 원칙"
folder: "oop"
categories:
  - oop
permalink: categories/oop/1
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 리스코프 치환 원칙
아래 코드에서 Square는 Rectangle을 상속받는다.

```java
public class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }
    public int getArea() { return width * height; }
}

public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height;
    }
}
```

<br>
Rectangle을 인자로 받아 사용하는 클라이언트 코드는 다형성에 의해 Square 타입도 받을 수 있는데, 이때 가로세로가 고정되어 버리는 문제가 발생한다.

수학적으로는 정사각형이라면 직사각형에 포함되는 것이 맞지만, 프로그래밍 상속 관계에서는 직사각형의 규격을 지워버리는 결과를 가져온다.

리스코프 치환 원칙이란, 부모 클래스의 명세(약속)를 자식 클래스가 위반하지 않아야 한다는 약속이다.

보통 명세를 인터페이스를 통해 역할을 분리하거나, 합성(Composition)을 활용함으로써 해결한다.

아래는 전략 패턴으로 불리는 디자인 패턴인데, 전략 패턴은 합성을 필수적으로 사용한다.

```java
interface WeaponStrategy {
    void attack();
}

class Sword implements WeaponStrategy {
    public void attack() { System.out.println("칼 휘두르기!"); }
}

class Bow implements WeaponStrategy {
    public void attack() { System.out.println("활 쏘기!"); }
}

class GameCharacter {
    private WeaponStrategy weapon; // 합성 (has-a)

    public void setWeapon(WeaponStrategy weapon) {
        this.weapon = weapon;
    }

    public void fight() {
        if(weapon == null) {
            System.out.println("맨손 공격!");
        } else {
            weapon.attack();
        }
    }
}
```