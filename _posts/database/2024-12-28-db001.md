---
layout: single
title:  "무결성 제약 조건, B-tree와 B+tree"
folder: "database"
categories:
  - database
permalink: categories/database/1
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 데이터베이스와 엔티티
여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리되는 데이터의 집합을 데이터베이스라고 한다.

데이터베이스에는 다양한 속성을 가진 개체들이 저장될 수 있는데, 이를 엔티티(Entity)라 한다. 또한, 앞서 언급한 속성은 각 엔티티를 결정짓는 특성을 의미한다.

한편, 동일한 속성을 모두 공유하는 개별 엔티티들을 한데 묶어 집합을 형성할 수 있는데, 이를 엔티티 집합이라 한다.

엔티티, 속성, 엔티티 집합으로 각각 정의된 데이터가 실제 데이터베이스에 저장되면 명칭이 조금 달라진다. 말하자면 데이터베이스에 저장 \'가능\'한 대상에서 데이터베이스에 저장\'된\' 대상이 되는 것이다.

엔티티는 RDBMS에서 레코드(행)으로, 속성은 필드(열)로 부르게 되며, 엔티티 집합은 테이블(릴레이션)로 정의된다.

스키마(Schema)란 데이터베이스에 저장되는 레코드의 구조와 제약 조건을 정의한 것이다. RDBMS와 NoSQL(Not only SQL)을 구분하는 주요 기준 중 하나로 스키마의 유무를 따진다. NoSQL은 스키마가 없는(Schemaless) 구조로, 특별히 레코드를 도큐먼트로, 필드를 JSON 형태의 키로 표현한다.

## 무결성 제약 조건
무결성 제약 조건이란, 데이터베이스에 저장된 데이터의 일관성과 정확성을 유지하기 위한 조건을 말한다. 데이터베이스에 저장된 데이터들은 반드시 무결성이 보장되어야 하며, 아래 조건들을 모두 만족해야 한다.

	1. 도메인 제약 조건: 테이블 내 레코드는 각 속성 도메인마다 제약된 조건의 값만 가져야 한다.
    
    2. 키 제약 조건: 레코드를 고유하게 식별할 수 있는 키로 지정된 속성의 필드는 중복된 값이
       존재할 수 없다.
    
	3. 엔티티 무결성 제약 조건(기본 키 제약 조건): 기본 키는 키 제약 조건을 만족하면서
       동시에 NULL 값을 가질 수 없다. 또한 기본 키는 테이블 내 하나만 정의할 수 있다.
    
	4. 참조 무결성 제약 조건(외래 키 제약 조건): 외래 키는 참조하는 테이블의 기본 키가
       가지는 범위 내 값만 가질 수 있으나, 예외로 중복과 NULL 값이 허용된다.

## B-tree
인덱스(Index)는 데이터베이스 테이블에 대한 검색 성능을 높이기 위해 사용하는 \'자료구조\'로, 일반적으로 B-tree 또는 이를 변형한 B+tree 구조를 기반으로 한다.

왜 B-tree를 사용할까? 이진 탐색 트리는 평균적으로 O(log N)의 탐색 성능을 제공하지만, 데이터 입력이 정렬된 순서대로 들어와 트리에 저장된다면 그 성능이 O(N)까지 떨어질 수 있다. 반면 B-tree는 <a href="https://youtu.be/aZjYr87r1b8?si=CyLjMgKso0AsY03Q" target="_blank" rel="noopener noreferrer"> M-way Search Tree</a> 구조를 사용해 각 노드에 여러 개의 키를 저장하여 트리 균형을 유지할 수 있다. 즉, BST에 비해 트리 높이가 낮아져 삽입과 삭제, 탐색 연산을 안정적으로 수행할 수 있는 것이다.

B-tree는 각 노드마다 키와 함께 레코드 포인터(Record Pointer)와 자식 포인터(Child Pointer)를 저장한다. 키는 검색 기준이 되는 값이며, 레코드 포인터는 해당 키에 연결된 실제 데이터의 주소를, 자식 포인터는 트리 구조상 다음 하위 노드를 가리킨다. 이처럼 B-tree는 내부 노드에 레코드 포인터가 저장되기 때문에, 탐색 도중 해당 데이터를 바로 참조할 수 있다.

                         [(cptr0), (key1, rptr1, cptr1), (key2, rptr2, cptr2)..]

<br>
M차 B-tree 생성에는 제약 사항이 있다. 각 노드가 최대 M개의 자식 포인터를 가질 수 있고, 루트를 제외한 모든 노드는 최소 ⌈M/2⌉개의 자식을 가져야 한다. 예를 들어 5-way B-tree의 경우 하나의 노드는 최대 4개의 키와 5개의 자식 포인터(5-way)를 가질 수 있으며, 최소 3개의 키와 4개의 자식 포인터를 가져야 한다.

이처럼 B-tree는 하나의 노드에 여러 개의 키를 저장해 탐색 시 디스크 접근 횟수를 줄일 수 있기 때문에 대용량 데이터를 다루는 데이터베이스 설계에 적합하다.

## B+tree
하지만 B-tree는 전체 데이터를 순차적으로 조회할 때 약간의 비효율이 발생한다. 리프 노드끼리 연결되지 않아 순회 시 루트 노드부터 다시 탐색 경로를 따라가야 하는 문제가 발생한다. 이런 문제점을 해결하기 위해 등장한 것이 B+tree다.

B+tree는 모든 키에 대한 레코드 포인터를 리프 노드(최하위 노드)에만 저장한다. 내부 노드는 키와 자식 포인터만을 가지며, 키는 단지 범위를 분할하고 리프 노드로 가는 경로를 안내하는 역할을 한다. 가장 큰 특징은 리프 노드들이 포인터로 연결 리스트처럼 이어져 있다는 점이다. 덕분에 전체 순회나 범위 검색이 매우 빠르게 수행된다. 순회 시 루트 노드로 다시 올라갈 필요 없이 리프 노드만 따라가면 되기 때문이다.

정리하면, B-tree는 균형 트리로서 삽입, 삭제, 검색이 빠르고 안정적이지만, 전체 순회나 범위 검색에 있어 다소 비효율적이다(물론 일반적인 이진 트리보다는 좋은 성능을 보인다). 반면 B+tree는 모든 레코드 포인터를 리프 노드에 모아놓은 후 리프 노드 간 연결을 통해 순차 접근이 가능하기 때문에, 범위 쿼리나 정렬된 결과 조회에서 B-tree보다 더 적합한 방식이다. 이 때문에 오늘날 대부분의 데이터베이스 인덱스는 B+tree 기반으로 설계된다.