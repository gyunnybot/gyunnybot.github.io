---
layout: single
title:  "무결성 제약 조건, B-tree와 B+tree"
folder: "database"
categories:
  - database
permalink: categories/database/db001
tags: DB
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 데이터베이스와 엔티티
데이터베이스란, 프로그램에서 원하는 기능을 동작시키기 위해 마땅히 저장해야 하는 정보의 집합이라 할 수 있다. 데이터베이스에는 다양한 속성을 가진 독립적 개체들이 저장될 수 있는데, 이때 독립적으로 존재할 수 있는 객체를 엔티티(Entity)라 한다. 또한, 앞서 언급한 속성은 해당 엔티티를 결정짓는 특성을 의미한다.

한편, 동일한 속성을 모두 공유하는 개별 엔티티들을 한데 묶어 집합을 형성할 수 있는데, 이를 엔티티 집합이라 한다.

엔티티, 속성, 엔티티 집합으로 각각 정의된 데이터가 실제 데이터베이스로 소속되면 명칭이 조금 달라진다. 말하자면 데이터베이스에 저장 \'가능\'한 대상에서 데이터베이스에 저장\'된\' 대상이 되는 것이다.

엔티티는 RDBMS에서 레코드(행)으로 불리며, 속성은 필드(열)로 부르게 된다. 엔티티 집합은 테이블 또는 릴레이션이라고 한다.

스키마(Schema)란, 데이터베이스에 저장되는 레코드의 구조와 제약 조건을 정의한 것이다. RDBMS와 NoSQL(Not only SQL)을 구분하는 주요 기준 중 하나로 스키마의 유무를 따진다. NoSQL은 스키마가 없는(Schemaless) 구조로, 특별히 레코드를 도큐먼트로, 필드를 JSON 형태의 키로 표현한다.

## 무결성 제약 조건
무결성 제약 조건이란, 데이터베이스에 저장된 데이터의 일관성과 정확성을 유지하기 위한 조건을 말한다. 데이터베이스에 저장된 데이터들은 반드시 무결성이 보장되어야 하며, 아래 조건들을 모두 만족해야 한다.

	1. 도메인 제약 조건: 테이블 내 레코드들은 각 속성의 도메인에 지정된 값만 가져야 한다.
    
    2. 키 제약 조건: 레코드를 고유하게 식별할 수 있는 키로 지정된 속성의 필드는 중복된 값이
       존재할 수 없다.
    
	3. 엔티티 무결성 제약 조건(기본 키 제약 조건): 기본 키는 키 제약 조건을 만족하면서
       동시에 NULL 값을 가질 수 없다. 또한 기본 키는 테이블 내 하나만 정의할 수 있다.
    
	4. 참조 무결성 제약 조건(외래 키 제약 조건): 외래 키의 값은 참조하는 외부 테이블의 기본 키와
       같은 도메인 값을 가져야 한다. 한편, 외래 키는 기본 키와 다르게 중복과 NULL 값을 허용한다.

## B-tree와 B+tree
인덱스(Index)는 데이터베이스 테이블에 대한 검색 성능을 높이기 위해 사용하는 자료구조이며, 일반적으로 B-tree 또는 이를 변형한 B+tree 구조를 기반으로 한다.

왜 B-tree를 사용할까? 이진 탐색 트리는 평균적으로 O(log N)의 탐색 성능을 제공하지만, 데이터가 정렬된 순서로 삽입된 경우처럼 트리의 균형이 깨지면 O(N)까지 성능이 떨어질 수 있다. 반면 B-tree는 M-way Search Tree 구조를 기반으로 하고 있어 각 노드에 여러 개의 키를 저장할 수 있으며, 항상 균형을 유지하는 구조다. 이 덕분에 트리의 높이가 낮아져 삽입과 삭제, 탐색 연산을 안정적이고 빠르게 수행할 수 있다.

M차 B-tree는 각 노드가 최대 M개의 자식 포인터를 가질 수 있고, 루트를 제외한 모든 노드는 최소 ⌈M/2⌉개의 자식을 가져야 한다. 예를 들어 5차 B-tree라면 하나의 노드는 최소한 3개의 키와 4개의 자식 포인터는 있어야 하며, 최대 4개의 키와 5개의 자식 포인터를 가질 수 있다. 이처럼 B-tree 구조는 디스크 접근 횟수를 줄이기 때문에 대용량 데이터를 다루는 데이터베이스에 적합하다.

B-tree는 각 노드마다 키와 함께 레코드 포인터(Record Pointer)와 자식 포인터(Child Pointer)를 저장한다. 키는 검색 기준이 되는 값이며, 레코드 포인터는 해당 키에 연결된 실제 데이터의 주소를, 자식 포인터는 트리 구조상 다음 하위 노드를 가리킨다. 이처럼 B-tree는 내부 노드에 레코드 포인터를 저장할 수 있기 때문에, 탐색 도중 해당 데이터를 바로 참조할 수 있다.

              [ (Key1(idx1), RecordPtr1(0x01)), (Key2, RecordPtr2), ..., (ChildPtr0, ChildPtr1, ...) ]

<br>
하지만 B-tree는 전체 데이터를 순차적으로 조회할 때 약간의 비효율이 발생한다. 중간 노드가 다르면 현재 노드 이후 다음 노드를 탐색할 때 루트 노드부터 다시 탐색 경로를 따라가야 하는 경우가 생긴다. 이런 문제점을 해결하기 위해 등장한 것이 B+tree다.

B+tree는 모든 키에 대한 레코드 포인터를 리프 노드에만 저장한다. 내부 노드는 키와 자식 포인터만을 가지며, 키는 단지 범위를 분할하고 리프 노드로 가는 경로를 안내하는 역할을 한다. 가장 큰 특징은 리프 노드들이 포인터로 연결 리스트처럼 이어져 있다는 점이다. 이 구조 덕분에 전체 순회나 범위 검색이 매우 빠르게 수행된다. 루트 노드로 다시 올라갈 필요 없이 리프 노드만 따라가면 되기 때문이다.

정리하면, B-tree는 균형 트리로서 삽입, 삭제, 검색이 빠르고 안정적이지만, 전체 순회나 범위 검색에 있어 다소 비효율적이다(물론 일반적인 이진트리보다는 좋은 성능을 보인다). 반면 B+tree는 모든 데이터를 리프 노드에 모아놓은 후 리프 간 연결을 통해 순차 접근이 가능하기 때문에, 범위 쿼리나 정렬된 결과 조회에서 B-tree보다 더 적합한 방식이다. 이 때문에 오늘날 대부분의 데이터베이스 인덱스는 B+tree 기반으로 설계된다.