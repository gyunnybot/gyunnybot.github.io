---
layout: single
title:  "Index_type : BTREE"
folder: "database"
categories:
  - database
permalink: categories/database/1
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## B-tree
인덱스(Index)는 데이터베이스 테이블에 대한 검색 성능을 높이기 위해 사용하는 자료구조로, B-tree 또는 이를 변형한 B+tree 구조를 기반으로 한다.

왜 B-tree를 사용할까? 이진 탐색 트리는 평균적으로 O(log N)의 탐색 성능을 제공하지만, 데이터 입력이 정렬된 순서대로 들어올 경우, 그 성능이 O(N)까지 떨어질 수 있다.

반면 B-tree는 <a href="https://youtu.be/aZjYr87r1b8?si=CyLjMgKso0AsY03Q" target="_blank" rel="noopener noreferrer"> M-way Search Tree</a> 구조를 사용해 각 노드마다 여러 개의 키를 저장하여 트리 균형을 유지한다. BST에 비해 트리 높이가 낮아져 전반적인 쿼리 연산을 안정적으로 수행할 수 있는 것이다.

B-tree는 각 노드마다 키와 함께 레코드 포인터(Record Pointer)와 자식 포인터(Child Pointer)를 저장한다. 키는 검색 기준이 되는 값이며, 레코드 포인터는 해당 키에 연결된 실제 데이터의 주소를, 자식 포인터는 트리 구조상 다음 하위 노드를 가리킨다. 이처럼 B-tree는 내부 노드에 레코드 포인터가 저장되기 때문에, 탐색 도중 해당 데이터를 바로 참조할 수 있다.

                          [(cptr0), (key1, rptr1, cptr1), (key2, rptr2, cptr2)..]

<br>
이처럼 B-tree는 하나의 노드에 여러 개의 키를 저장해 탐색 시 디스크 접근 횟수를 줄일 수 있기 때문에 대용량 데이터를 다루는 데이터베이스 설계에 적합하다 할 수 있다.

## B+tree
하지만 B-tree는 전체 데이터를 순차적으로 조회할 때 약간의 비효율이 발생한다. 리프 노드끼리 연결되지 않아 BETWEEN 연산 등으로 인한 데이터 순회 시 루트 노드부터 다시 탐색 경로를 따라가야 하는 문제가 발생한다.

B+tree는 모든 키에 대한 레코드 포인터를 리프 노드(최하위 노드)에만 저장한다. 내부 노드는 키와 자식 포인터만을 가지며, 키는 단지 범위를 분할하고 리프 노드로 가는 경로를 안내하는 역할을 한다.

가장 큰 특징은 리프 노드들이 포인터로 연결 리스트처럼 이어져 있다는 점이다. 루트 노드로 다시 올라갈 필요 없이 리프 노드만 따라가면 되기 때문에 전체 순회나 범위 검색이 매우 빠르게 수행된다.

정리하면, B-tree는 균형 트리로서 삽입, 삭제, 검색이 빠르고 안정적이지만, 전체 순회나 범위 검색에 있어 다소 비효율적이다(물론 일반적인 이진 트리보다는 좋은 성능을 보인다).

반면 B+tree는 모든 레코드 포인터를 리프 노드에 모아놓은 후 리프 노드 간 연결을 통해 순차 접근이 가능하기 때문에, 범위 쿼리나 정렬된 결과 조회에서 B-tree보다 더 적합한 방식이다. 이 때문에 오늘날 대부분의 데이터베이스 인덱스는 B+tree 기반으로 설계된다.