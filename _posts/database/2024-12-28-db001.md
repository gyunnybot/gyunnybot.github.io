---
layout: single
title:  "무결성 제약 조건, B-tree와 B+tree"
folder: "database"
categories:
  - database
permalink: categories/database/db001
tags: DB
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 무결성 제약 조건
무결성 제약 조건이란, 데이터베이스에 저장된 데이터의 일관성과 정확성을 유지하기 위한 조건을 말한다. 데이터베이스에 저장된 데이터들은 반드시 무결성이 보장되어야 하며, 아래 조건들을 모두 만족해야 한다.

	1. 도메인 제약 조건: 테이블 내 레코드들은 각 속성의 도메인에 지정된 값만 가져야 한다.
    
    2. 키 제약 조건: 레코드를 고유하게 식별할 수 있는 키로 지정된 속성의 필드는 중복된 값이
       존재할 수 없다.
    
	3. 엔티티 무결성 제약 조건(기본 키 제약 조건): 기본 키는 키 제약 조건을 만족하면서
       동시에 NULL 값을 가질 수 없다. 또한 기본키는 테이블 내 하나만 정의할 수 있다.
    
	4. 참조 무결성 제약 조건(외래 키 제약 조건): 외래 키의 값은 참조하는 테이블의 기본 키와
       같은 도메인 값을 가져야 한다. 외래 키는 기본 키와 다르게 중복과 NULL 값을 허용한다.

## B-tree와 B+tree
인덱스(Index)는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조로 활용되며, 일반적으로 B-tree 형태의 구조를 가진다.

왜 B-tree를 사용할까? 일반적인 이진 탐색 트리는 데이터를 탐색할 때 O(logN)의 시간 복잡도를 가지지만, 최악의 경우 선형(변질된 이진 트리)이 되어 O(n)의 시간 복잡도를 가지게 된다. 그에 비해 B-tree는 M-way Search Tree 알고리즘을 적용해 더 균형 있고 높이가 낮은 트리를 생성하여 비교적 보장된 성능과 안정성을 제공한다.

M-way Search Tree는 각 노드에 키를 [M/2] 이상 가져야 한다. 예를 들어 5차 B-tree의 경우 중간 노드는 반드시 3개 이상의 Key를 포함해야 하며, 그 자식 노드 수는 (Key + 1)개로 고정된다. 따라서 일반적인 트리보다 B-tree 구조가 데이터 저장에 더 적합하다.

B-tree는 각 노드마다 Key에 대응되는 실제 데이터 주소(Record Pointer)와 자식 노드를 가리키는 주소(Child Pointer)를 함께 저장한다. B-tree는 일반적으로 Key를 활용해 인덱스를 생성하기 때문에 노드에 도달한 후 키 값만 알게 되면 그에 해당하는 데이터를 바로 찾을 수 있다.

하지만 B-tree는 리프 노드가 아닌 노드에서도 데이터 주소를 가지기 때문에 전체 순회 시 다음 데이터가 다른 갈래의 노드에 저장되어 있다면 루트 노드로 올라가 해당 노드까지 다시 탐색해야 한다.

오늘날 인덱스는 B-tree를 변형한 B+tree를 많이 사용한다. B+tree는 실질적인 데이터(의 주소)가 전부 리프 노드에 저장된다. Key는 단지 범위를 분할해 리프 노드로 안내하는 용도로 사용된다.

또한 B+tree의 리프 노드끼리는 연결 리스트 방식으로 이어져 있어 전체 순회 시 B-tree처럼 루트 노드로 올라갈 필요 없이 곧바로 다음 인덱스에 접근할 수 있다. 따라서 B+tree 구조는 B-tree보다 전체 순회, 범위 연산에 훨씬 효율적인 자료구조이다.