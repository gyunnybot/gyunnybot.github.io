---
layout: single
title:  "데이터베이스"
folder: "database"
categories:
  - database
tags: DB
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 무결성 제약 조건
무결성 제약 조건이란 데이터베이스에 저장된 데이터의 일관성과 정확성을 유지하기 위한 조건을 말합니다.

	1. 도메인 제약 조건: 각각의 필드 값은 해당 속성의 타입과 도메인이 일치해야 합니다.
    
       2. 키 제약 조건: 레코드를 고유하게 식별할 수 있는 키로 지정된 필드에는 중복된 값이
       존재할 수 없습니다.
    
	3. 엔티티 무결성 제약 조건(기본 키 제약 조건): 기본 키는 키 제약 조건을 만족하면서
       하나의 값을 가지며 동시에 NULL 값을 가질 수 없습니다.
    
	4. 참조 무결성 제약 조건(외래 키 제약 조건): 외래 키의 값은 참조하는 테이블의 기본 키와
       같은 도메인의 값을 가져야 합니다. 기본 키와 다르게 중복과 NULL 값을 허용합니다.

## B-tree와 B+tree
<span style="color: rgb(3, 150, 150); font-weight: bold;">`인덱스(Index)`</span>는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조를 뜻하며 일반적으로 <span style="color: rgb(3, 150, 150); font-weight: bold;">`B-tree`</span> 형태의 구조를 가집니다.

왜 B-tree를 사용할까요? 이진 탐색 트리는 최악의 경우 트리가 선형(변질 이진 트리)이 되어 O(n)의 시간 복잡도를 가지게 됩니다. 그에 비해 B-tree는 좀 더 균형 있고 높이가 낮은 트리를 자동으로 구성해 비교적 보장된 성능과 안정성을 제공합니다.

B-tree는 각 노드마다 Key에 대응되는 실제 데이터 주소(record pointer)와 자식 노드를 가리키는 주소(child pointer)를 함께 저장합니다. B-tree는 일반적으로 Key를 활용해 인덱스를 생성하기 때문에 키 값을 알게되면 그에 해당하는 데이터를 바로 찾을 수 있습니다.

하지만 리프 노드가 아닌 노드에서도 데이터 주소를 가질 수 있기 때문에 전체 순회를 할 때 다음 데이터가 다른 갈래의 노드에 저장되어 있다면 루트 노드로 올라가 해당 노드까지 다시 탐색해야 합니다.

오늘날 인덱스는 B-tree를 변형한 <span style="color: rgb(3, 150, 150); font-weight: bold;">`B+tree`</span>를 많이 사용합니다. B+tree는 실질적인 데이터(의 주소)가 **전부 리프 노드**에 저장됩니다. Key는 단지 범위를 분할하여 리프 노드로 안내하는 용도로 사용됩니다. 또한 B+tree의 리프 노드끼리는 연결 리스트 방식으로 이어져 있어 B-tree처럼 루트 노드로 올라갈 필요 없이 곧바로 다음 인덱스에 접근할 수 있습니다. 따라서 B+tree 구조는 B-tree보다 전체 순회, 범위 연산에 훨씬 적합한 자료구조입니다.
