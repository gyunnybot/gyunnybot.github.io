---
layout: single
title:  "동시성 제어, 트랜잭션 고립 수준"
folder: "database"
categories:
  - database
permalink: categories/database/db003
tags: DB
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 트랜잭션의 성질
데이터베이스에서 데이터를 다루는 논리적인 작업 단위를 트랜잭션(Transaction)이라 한다.

트랜잭션 작업은 원자성, 일관성, 고립성, 지속성 네 가지 원칙(ACID)을 준수해야 한다.

	1. 원자성: 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
    
    2. 일관성: 트랜잭션 수행 전후 데이터베이스는 항상 일관된 상태를 유지해야 한다.
    
    3. 고립성: 수행 중인 트랜잭션의 데이터 값이 다른 트랜잭션에 의해 훼손되는 일이 없어야 한다.
    
    4. 지속성: 트랜잭션 수행이 완료된 결과는 데이터베이스에 영구적으로 반영되어야 한다.

<br>
DBMS는 동시성 제어를 통해 일관성과 고립성을, 로그 파일을 활용한 회복 과정을 통해 원자성과 지속성을 유지한다.

## 동시성 제어
단일 트랜잭션에서 데이터를 삽입, 수정할 때에는 무결성 제약 조건만으로도 일관성을 유지할 수 있지만, 여러 트랜잭션이 동시에 수행될 때는 동시성 제어 알고리즘이 반드시 필요하다.

동시성 제어에서는 트랜잭션이 수행하는 동작이 읽기인지 쓰기인지에 따라 제어 방식이 달라진다.

여러 트랜잭션이 하나의 데이터에 동시에 접근해 값의 수정, 변경을 진행하게 되면 갱신 손실(덮어쓰기) 문제가 발생할 수 있다. 이처럼 쓰기(Write) 트랜잭션이 동시에 수행되는 경우, 하나의 트랜잭션의 동작이 끝날 때까지 사용 중인 데이터에 대한 락(Lock)을 걸어 다른 트랜잭션의 데이터 접근을 막아 갱신 손실 문제를 해결할 수 있다. 동작이 끝나면 획득한 락을 해제한다.

트랜잭션이 락을 획득하는 단계에서는 이미 획득한 락에 대해 해제하지 않으며(확장), 해제 단계에서는 새로운 락을 획득하지 않는(수축) 진행 방식을 2단계 락킹(Two-Phase Locking Protocol)이라고 한다. 이는 트랜잭션이 완료될 때까지 데이터를 다른 트랜잭션의 접근으로부터 보호하는 기본 규칙이다.

두 개 이상의 트랜잭션에서 각자의 데이터에 대한 락을 획득하고 상대방 데이터에 대한 락을 요청할 때 서로 무기한 대기 상태에 빠지는 것을 데드락(Dead Lock)이라고 한다. DBMS는 데드락이 발생하면 임의의 트랜잭션을 선택하여 강제로 중지시키고(해당 트랜잭션이 획득한 락을 반납), 락이 해제된 데이터를 원상 복구(ROLLBACK)하는 방식으로 문제를 해결한다.

## 트랜잭션 고립 수준
읽기-쓰기 트랜잭션이 동시에 진행되는 상황에서는 읽기 트랜잭션에서 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 등의 문제가 발생할 수 있다.

	1. 오손 읽기: 읽기 트랜잭션이 롤백(ROLLBACK) 이전의 쓰기 트랜잭션 결과 데이터를 읽어 
       잘못된 값을 반환하는 경우
    
    2. 반복불가능 읽기: 쓰기 트랜잭션에서 데이터의 변경이 발생한 이후 읽기에서 이전 결과가
       보이지 않는 경우(데이터가 쓰기 트랜잭션에 의해 갱신되어 읽기 트랜잭션 입장에서는
       같은 명령어로 다른 값이 도출되는 상황)
    
    3. 유령데이터 읽기: 쓰기 트랜잭션에서 데이터의 삽입이 발생한 후 읽기 트랜잭션에서
       같은 명령어로 이전에 없던 새로운 데이터가 보이는 경우

<br>
락킹 기법으로도 해당 문제를 강력하게 해결할 수 있지만, 읽기 트랜잭션의 경우 고립 수준 명령어를 통한 완화된 동시성 제어를 활용해 동시성을 유연하게 높일 수 있다.

고립 수준 명령어는 읽기-쓰기 트랜잭션이 경합하는 상황에서 고려할 수 있는 옵션이다. 모든 명령어는 갱신 손실 문제를 예방하기 위해 배타 락(쓰기 락)은 필수로 설정하지만, 공유 락(읽기 락)의 경우 다른 트랜잭션의 데이터를 어디까지 다룰 수 있는지 여부에 따라 다른 고립 수준을 보인다.

수준이 높을수록 제어의 강도는 높아진다.

	1. READ UMCOMMITED(Level = 0): 자신의 데이터에 공유 락을 설정하지 않으며(해제), 쓰기 트랜잭션의
       데이터를 어떤 상황에서도 전부 읽을 수 있다.
       
       위 문제들 중 어느 하나도 해결할 수 없다.
       
    2. READ COMMITED(Level = 1): 자신의 데이터에 공유 락을 설정하며, 쓰기 트랜잭션이
       commit한 데이터만 읽을 수 있다.
       
       오손 읽기 문제를 해결할 수 있다.
       
    3. REPEATABLE READ(Level = 2): 자신의 데이터에 공유 락을 설정하며, 트랜잭션이 시작된 시점에
       읽은 데이터를 트랜잭션이 끝날 때까지 동일하게 유지한다.
       
       오손 읽기, 반복불가능 읽기 문제를 해결할 수 있다.
       
    4. SERIALIZABLE(Level = 3): 가장 고립 수준이 높은 명령어로, 공유 락을 인덱스로 설정해
       다른 트랜잭션의 데이터 추가, 삭제를 막는다. 트랜잭션이 마치 직렬로 실행되는 것처럼
       동작한다.
       
       모든 문제를 해결할 수 있다.

## 회복
트랜잭션은 데이터 변경 내용을 한순간에 데이터베이스에 저장하는 것이 아니라, 로그 파일(Log)에 먼저 기록한 후 데이터베이스에 반영한다. 따라서 데이터베이스의 회복 과정은 로그 파일을 활용하여 진행한다.

로그에는 데이터가 변경(쓰기 작업)된 기록만이 남는데, 즉시갱신과 지연갱신 두 가지 방식으로 데이터를 데이터베이스에 전달한다. 즉시갱신은 로그 파일에 트랜잭션에 대한 부분 완료(commit)가 없어도 실시간으로 데이터베이스에 반영하는 방식이다. 반면에 지연갱신은 로그에 부분 완료가 이루어진 트랜잭션만 데이터베이스에 반영한다.

즉시갱신은 로그와 데이터베이스 간의 데이터 일관성이 높아지지만 시스템 운영 시 데이터베이스에 요구하는 입출력 연산이 증가한다는 단점이 있고, 지연갱신은 시스템 복구 시 즉시갱신에 비해 복구 시간이 오래 걸린다는 단점이 있다.

회복 단계에서 많은 양의 로그를 검색, 갱신하는 시간을 줄이기 위해 일정 시간 간격으로 데이터베이스와 로그 파일을 동기화한 시점을 역시 로그 파일에 기록하는데, 이를 체크포인트(Check Point)라고 한다.

체크포인트 이후에 시스템 장애가 발생했다고 가정해 보자. 체크포인트와 장애 사이에 트랜잭션이 부분 완료된 경우에는 장애가 발생하기 전까지 데이터베이스에 변경 사항이 실제로 반영되지 않았을 확률이 있기 때문에 즉시, 지연갱신 방식 모두 트랜잭션을 재실행(REDO)한다.

한편 시스템 장애 이후 부분 완료된 경우 즉시갱신은 취소(UNDO) 명령어를 수행해 조각 데이터베이스 기록을 지우고 체크포인트로 돌아간다. 지연갱신(NO UNDO, REDO)의 경우 데이터베이스에 실제로 기록된 내용이 없기 때문에 아무 동작 없이 바로 체크포인트로 돌아가 재실행을 해도 문제가 되지 않는다.