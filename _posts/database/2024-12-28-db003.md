---
layout: single
title:  "동시성 제어, 트랜잭션 고립 수준"
folder: "database"
categories:
  - database
tags: DB
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 트랜잭션(Transaction)의 성질
데이터를 다루는 논리적인 작업의 단위를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`트랜잭션`</span>이라고 합니다.

트랜잭션은 원자성, 일관성, 고립성, 지속성 네 가지 성질을 포함합니다(ACID).

	1. 원자성: 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 합니다.
    
    2. 일관성: 트랜잭션 수행 전후 데이터베이스는 항상 일관된 상태를 유지해야 합니다.
    
    3. 고립성: 수행 중인 트랜잭션의 데이터 값이 다른 트랜잭션에 의해 훼손되는 일이 없어야 합니다.
    
    4. 지속성: 트랜잭션 수행이 완료된 결과는 데이터베이스에 영구적으로 반영되어야 합니다.

DBMS는 **동시성 제어**를 통해 일관성과 고립성을, 로그 파일을 활용한 **회복** 과정을 통해 원자성과 지속성을 유지합니다.

## 동시성 제어
단일 트랜잭션에서 데이터를 삽입, 수정할 때는 기존의 무결성 제약 조건만으로도 일관성을 유지할 수 있지만, 여러 트랜잭션이 동시에 수행될 때는 동시성 제어 알고리즘이 반드시 필요합니다.

트랜잭션이 수행하는 동작이 읽기인지 쓰기인지에 따라 제어 방식이 달라집니다.

여러 트랜잭션이 하나의 데이터에 동시에 접근해 값의 수정, 변경을 진행하게 되면 <span style="color: rgb(3, 150, 150); font-weight: bold;">`갱신 손실(덮어쓰기)`</span> 문제가 발생할 수 있습니다. 이처럼 쓰기(Write) 트랜잭션이 동시에 수행되는 경우, 하나의 트랜잭션의 동작이 끝날 때까지 사용 중인 데이터에 대한 <span style="color: rgb(3, 150, 150); font-weight: bold;">`락(Lock)`</span>을 걸어 다른 트랜잭션의 데이터 접근을 막아 갱신 손실 문제를 해결할 수 있습다. 동작이 끝나면 획득한 락을 해제합니다.

트랜잭션이 락을 획득하는 단계에서는 이미 획득한 락에 대해 해제하지 않으며(확장 단계), 락을 해제하는 단계에서 새로운 락을 획득하지 않는(수축 단계) 진행 방식을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`2단계 락킹(Two-Phase Locking Protocol)`</span>이라고 합니다. 트랜잭션이 완료될 때까지 데이터를 다른 트랜잭션의 접근으로부터 보호합니다.

두 개 이상의 트랜잭션에서 각자의 데이터에 대한 락을 획득하고 상대방의 데이터에 대한 락을 요청할 때 서로 무기한 대기 상태에 빠지는 것을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`데드락(Dead Lock)`</span>이라고 합니다. DBMS는 데드락이 발생하면 임의의 트랜잭션을 선택하여 강제로 중지시키고(해당 트랜잭션이 획득한 락을 해제합니다) 락이 해제된 데이터를 원상 복구(롤백)하는 방식으로 문제를 해결합니다.

## 트랜잭션 고립 수준
읽기-쓰기 트랜잭션이 동시에 진행되는 경우 읽기 트랜잭션에서 **오손 읽기, 반복불가능 읽기, 유령데이터 읽기** 등의 문제가 발생할 수 있습니다.

	1. 오손 읽기: 읽기 트랜잭션이 롤백(ROLLBACK) 이전의 쓰기 트랜잭션 결과 데이터를 읽어 
       잘못된 결과를 가져오는 경우
    
    2. 반복불가능 읽기: 쓰기 트랜잭션에서 데이터의 변경이 발생한 이후 읽기에서 이전 결과가
       보이지 않는 경우(데이터가 쓰기 트랜잭션에 의해 갱신되어 읽기 트랜잭션 입장에서
       같은 명령어로 다른 값이 도출되는 상황을 말합니다)
    
    3. 유령데이터 읽기: 쓰기 트랜잭션에서 데이터의 삽입이 발생할 때 읽기 트랜잭션에서
       같은 명령어로 이전에 없던 새로운 데이터가 보이는 경우

락킹 기법으로도 해당 문제를 해결할 수 있지만, 읽기 트랜잭션의 경우 DBMS의 동시성을 높이기 위해 고립 수준 명령어를 통한 **완화된 동시성 제어**를 활용할 수 있습니다.

고립 수준 명령어는 읽기-쓰기 트랜잭션이 경합하는 상황에서 고려할 수 있는 옵션입니다. 모든 명령어는 갱신 손실 문제를 예방하기 위해 배타 락(쓰기 락)은 필수로 설정하지만, 공유 락(읽기 락)은 다른 트랜잭션의 데이터를 어디까지 다룰 수 있는지 여부에 따라 다른 고립 수준을 보입니다. 수준이 높을수록 제어의 강도가 높아집니다.

	1. READ UMCOMMITED(Level = 0): 자신의 데이터에 공유 락을 설정하지 않으며(해제), 쓰기 트랜잭션의
       데이터를 어떤 상황에서도 전부 읽을 수 있습니다.
       
       위 문제들 중 어느 하나도 해결할 수 없습니다.
       
    2. READ COMMITED(Level = 1): 자신의 데이터에 공유 락을 설정하며, 쓰기 트랜잭션이
       commit한 데이터만 읽을 수 있습니다.
       
       오손 읽기 문제를 해결합니다.
       
    3. REPEATABLE READ(Level = 2): 자신의 데이터에 공유 락을 설정하며, 트랜잭션이 시작된 시점에
       읽은 데이터를 트랜잭션이 끝날 때까지 동일하게 유지합니다. 
       
       오손 읽기, 반복불가능 읽기 문제를 해결합니다.
       
    4. SERIALIZABLE(Level = 3): 가장 고립 수준이 높은 명령어로, 공유 락을 인덱스로 설정해
       다른 트랜잭션의 데이터 추가, 삭제를 막습니다. 트랜잭션이 마치 직렬적으로 실행되는 것처럼
       동작합니다.
       
       모든 문제를 해결합니다.

## 회복
트렌잭션은 데이터 변경 내용을 한순간에 데이터베이스에 저장하는 것이 아니라, 변경 내용을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`로그 파일(Log)`</span>에 먼저 기록 후 데이터베이스에 반영합니다. 따라서 데이터베이스의 회복 과정은 로그 파일을 활용하여 진행됩니다.

로그에는 데이터가 변경(쓰기 작업)된 기록만이 남는데, 즉시갱신과 지연갱신 두 가지 방식으로 데이터를 데이터베이스에 전달합니다. <span style="color: rgb(3, 150, 150); font-weight: bold;">`즉시갱신`</span>은 로그 파일에 트랜잭션에 대한 부분 완료(commit)가 없어도 실시간으로 데이터베이스에 반영하는 방식입니다. 반면 <span style="color: rgb(3, 150, 150); font-weight: bold;">`지연갱신`</span>은 부분 완료가 이루어진 트랜젝션의 데이터만 데이터베이스에 반영합니다. 즉시갱신은 시스템 운영 시 데이터베이스에 입출력 연산이 증가한다는 단점이 있고, 지연갱신은 시스템 복구 시 복구 시간이 즉시갱신에 비해 오래 걸린다는 단점이 있습니다.

회복 단계 과정에서 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위해 일정 시간 간격으로 데이터베이스와 로그 파일을 동기화한 시점을 역시 로그 파일에 기록하는데, 이를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`체크포인트(Check Point)`</span>라고 합니다.

체크포인트 이후에 시스템 장애가 발생했다고 가정해봅시다. 체크포인트와 장애 사이에 트랜잭션이 부분 완료된 경우 장애가 발생하기 전까지 데이터베이스에 변경 사항이 실제로 반영되지 않았을 확률이 있기 때문에 즉시, 지연갱신 전부 트랜잭션을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`재실행(REDO)`</span>합니다. 반면 시스템 장애 이후 부분 완료된 경우 즉시갱신은 <span style="color: rgb(3, 150, 150); font-weight: bold;">`취소(UNDO)`</span> 명령어를 수행해 데이터베이스의 기록을 지우고 체크포인트로 돌아가야 합니다. 지연 갱신(NO UNDO, REDO)의 경우 데이터베이스에 실제로 기록된 내용이 없으므로 아무 명령도 수행하지 않고 체크포인트로 돌아가도 문제가 되지 않습니다.