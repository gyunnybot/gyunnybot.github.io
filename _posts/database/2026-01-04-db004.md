---
layout: single
title:  "MySQL 실행 계획에서 type 알아보기"
folder: "database"
categories:
  - database
permalink: categories/database/4
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 실행 계획 : type에 대하여
어떤 쿼리가 실행될 때 테이블의 데이터를 어떤 방식으로 조회하는 지 알 수 있다. EXPLAIN 키워드를 쿼리 앞에 붙이면 말 그대로 실행 계획을 얻을 수 있는데, 이중 **type**이 앞서 언급한 내용을 반환한다.

대표적으로 \'ALL\', \'index\', \'const\', \'range\', \'ref\' 5가지를 알아보자.

먼저 ALL은 인덱스가 없거나(클러스터링 인덱스 제외), 조건절에서 다루는 컬럼에 대한 인덱스가 존재하지 않아 실제 테이블의 데이터 전체를 가지고 쿼리를 실행할 때 표시되는 타입이다. 풀 테이블 스캔(Full Table Scan)이라고 한다.

```sql
   EXPLAIN
   SELECT * FROM users; -- PK를 제외하고 아직 아무런 인덱스가 없다면
```

<br>
반대로 index는 생성된 인덱스(고유/비고유 모두 가능)가 있어, 이를 토대로 데이터를 탐색해 쿼리 결과를 나타낼 때의 타입이다. 보통 쿼리가 인덱스를 타면서 동시에 ORDER BY + LIMIT을 요구할 때 사용되는 실행 계획 타입이다.

```sql
   CREATE INDEX idx_name ON users(name);

   EXPLAIN
   SELECT * FROM users
   ORDER BY name
   LIMIT 10;
```

<br>
const는 고유 인덱스를 통해 `=` 조건 조회를 할 때의 타입이다. 고유 인덱스란, PK 또는 UNIQUE로 지정된 컬럼으로 생성된 인덱스를 말한다. MySQL에서 PK 또는 UNIQUE로 지정된 컬럼은 자동으로 인덱스가 생성되는데, 조회 쿼리 실행 시 만족하는 행이 반드시 1건으로 확정되므로 const라는 이름으로 타입이 반환된다.

```sql
   EXPLAIN
   SELECT * FROM users
   WHERE id = 1;

   EXPLAIN
   SELECT * FROM users
   WHERE email = 'a@b.com'; -- UNIQUE(email) 가정
```

<br>
range는 인덱스(고유/비고유 모두 가능)를 활용해 범위 연산, LIKE, BETWEEN 연산이 진행될 때 반환되는 타입이다. 앞서 언급한 index는 생성된 인덱스 레코드 자체를 순서대로 스캔하다가 LIMIT으로 멈추는 방식이라면, range는 조건절을 통해 인덱스에서 조건을 만족하는 지점을 찾은 후, 해당 범위를 살피는 방식이다.

```sql
   EXPLAIN SELECT * FROM users WHERE name >= '박' AND name < '팍';
   EXPLAIN SELECT * FROM users WHERE name LIKE '박%';
   EXPLAIN SELECT * FROM users WHERE name BETWEEN '가' AND '마';
```

<br>
마지막으로 ref에 대해 알아보면, 비고유 인덱스를 통해 `=` 조건 조회를 할 때 실행 계획으로 잡히는 타입이다. 비고유 인덱스이기 때문에 const에 비해 쿼리의 결과 행이 반드시 한 건이 나옴을 보장할 수 없을 때 반환되는 타입이다. idx_name은 비고유 인덱스이므로 아래 쿼리의 실행 계획에서 타입은 ref가 된다.

```sql
   EXPLAIN
   SELECT * FROM users
   WHERE name = 'gyunnybot';
```