---
layout: single
title:  "내가 보려고 정리한 git 명령어, 사용법"
folder: "git"
categories:
  - git
permalink: categories/git/1
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

배우는대로 계속 추가 예정입니다.

<br>

작업 상태(변경 여부) 확인 :

    git status

<br>

변경된 파일 스테이징 :

    git add [filename]

<br>

변경된 모든 파일 한꺼번에 스테이징 :

    git add .

하나의 커밋 단위로 묶이게 되므로 커밋 메시지가 일괄로 전송됩니다. 따라서 커밋 메시지를 세분화해야 할 때는 사용하지 않습니다.

<br>

스테이징 취소 :

    git rm --cached [filename]

.gitignore에 filename을 추가 후 해당 명령어를 사용하면, 다음 커밋부터는 Git이 해당 파일을 추적하지 않습니다.

git은 workdir, stage, commit area로 이루어진 3가지 작업 단계를 가지는데, add와 commit은 각각 workdir -> stage, stage -> commit area로 파일을 \'복사\' 후 기록합니다.

따라서 .gitignore에 파일을 추가한 후 rm --cached 명령어를 사용하면 stage에 복사되었던 파일이 지워지고(삭제되었다는 추적 기록을 스테이징 합니다), 이후 커밋에서부터는 해당 파일이 커밋되지 않는 것입니다.

reset이나 revert는 과거 커밋이나 변경을 \'되돌리는\' 느낌이 강하다면, 해당 방식은 커밋 히스토리는 유지한 채 \'앞으로\' 특정 파일을 추적하지 말라는 의미가 강합니다.

<br>

커밋 :

    git commit -m "message"

<br>

Conventional Commit Style :

    feat: 새로운 기능 추가
    fix: 버그 수정
    docs: 문서 관련 수정
    style: 코드 동작에 영향 없이 코드스타일 수정
    refactor: 리팩터링
    test: 테스트 코드 추가, 수정, 삭제
    chore: .gitignore, 패키지 정리 등 잡무
    build: 빌드 시스템, 의존성 관련 변경
    revert: 이전 커밋 되돌리기

앞서 언급한 것처럼 커밋의 성격이 다르다면 add, commit을 각각 따로 실행해 커밋 메시지를 다르게 해야 합니다.

<br>

커밋 기록 조회 :

    git log

<br>

브랜치 생성하기 :

    git branch <브랜치 이름>

<br>

브랜치 목록 :

    git branch

<br>

브랜치 이름 변경하기 :

    git branch -m <기존 브랜치 이름> <새 브랜치 이름>

-m 대신 -M을 사용하면 이름이 겹치는 브랜치가 있어도 강제로 덮어씌워 변경합니다. -m을 사용해서 이름이 겹치는지 확인 후 변경하는 것이 일반적입니다. -M가 사용된 경우는 처음 원격과 로컬을 연결할 때 git branch -M main(현재 브랜치 master를 main으로 변경) 명령어밖에 본 적이 없네요.

<br>

다른 브랜치로 변경하기 :

    git checkout <브랜치 이름>

<br>

없던 브랜치를 생성하면서 변경하기 :

    git checkout -b <브랜치 이름>

<br>

브랜치 삭제 :

    안전 삭제 : git branch -d <브랜치 이름>

    강제 삭제 : git branch -D <브랜치 이름>

-d는 standard branch(처음 생성된 브랜치. 주로 main)에 병합되지 않은 브랜치는 삭제되지 않습니다. -D는 강제로 삭제합니다.

<br>

Merge 후 로컬에서 원격 저장소(github origin)에 남아있는 브랜치 삭제하기 :

    git push <원격 저장소 이름(보통 origin)> --delete <삭제할 브랜치 이름>

<br>

자신의 로컬과 연결된 원격 저장소 조회하기 :

    git remote -v

-v는 url 표시 옵션이나, 쓰는 것이 표준입니다.

<br>

원격 저장소 연결 추가하기 :

    git remote add <원격 저장소 이름> <원격 저장소 url>

<br>

원격 저장소 연결 해제하기 :

    git remote rm <원격 저장소 이름> <원격 저장소 주소>

<br>

로컬의 커밋 내용을 원격 저장소에 push하기 :

    git push -u <원격 저장소 이름> <로컬 브랜치 이름>

<br>

로컬의 커밋 기록을 처음 원격에 연결하고 push하기 :

    1. github 원격 저장소를 생성한다
    2. 로컬에서 git remote add origin <원격 저장소 주소>
    3. git branch -M <로컬의 첫 브랜치 이름(주로 main)>
    4. git push -u origin <로컬 브랜치 이름>

<br>

원격 저장소의 내용을 로컬로 가져와 업데이트하기 :

    git pull <원격 저장소 이름> <로컬 브랜치 이름>

<br>

원격 저장소의 내용을 로컬로 가져오기만 하기 :

    git fetch <원격 저장소 이름>

로컬의 파일은 영항받지 않습니다. FETCH_HEAD로 원격 저장소의 main 브랜치의 해시를 가져와 비교할 수 있으며, 이를 토대로 수정 가능합니다.

<br>

원격 저장소 클론 :

    git clone <원격 저장소 url>

github에서 windows는 HTTPS, mac은 **SSH**로 url을 복사해야 합니다. 또한 클론은 자동으로 원격-로컬 연결을 수행합니다.

<br>

커밋 되돌리기 1 :

    git reset --hard HEAD^ 
    -> 마지막 커밋 자체를 삭제하고, 작업 디렉토리/스테이징도 그 이전 커밋 상태로 맞춥니다.
        (위험! 마지막 커밋 내용과 변경 사항 전부 사라짐)

    git reset --mixed HEAD^ (# 기본값)
    -> 마지막 커밋을 삭제하지만, 변경된 내용은 작업 디렉토리(workdir)에 "수정됨" 상태로 남습니다.
        (index(스테이징)은 비워짐)

    git reset --soft HEAD^
    -> 마지막 커밋을 삭제하고, 그 커밋 내용이 그대로 index(staging area)에 올라간 상태로 남습니다.
        (커밋 메시지만 다시 쓰고 싶을 때 유용)

HEAD는 최신 커밋, ^는 하나, ^^는 2개 이전 커밋을 가리킵니다.

<br>

커밋 되돌리기 2 :

    git revert <되돌아가고 싶은 커밋 해시>

git reset은 되돌린 버전 이후의 버전들이 모두 사라지게 되지만, git revert는 되돌린 버전 이후의 버전들은 모두 유지되고, revert되었다는 사실을 담은 commit이 새로 추가되는 방식입니다.

<br>

현재 수정 사항(변경점) 확인 :

    git diff <A commit hash> <B commit hash>
    (A 커밋에 비해 B 커밋은 무엇이 달라졌나?)

    git diff HEAD^ HEAD
    (전전 커밋에 비해 직전 커밋은 무엇이 달라졌나? ^의 수에 따라 여러 비교 가능)

    git diff HEAD
    (현재 작업 디렉토리 수정내용을 직전 커밋과 비교 후 출력)

<br>

병합하기 :

    1. 병합의 결과가 되는 브랜치로 checkout
    2. git merge <합치려는 브랜치 이름>
    3. conflict 발생 시, 직접 수정 후 add -> commit 수행(both modified가 되며, 자동으로 merge됩니다)

언제 PR을 쓰고, 언제 그냥 merge만 해도 될까? 

혼자 하는 토이 프로젝트, 연습이라면 그냥 git checkout main && git merge my_branch && git push 정도면 충분합니다. 굳이 my_branch에서 main으로 PR은 불필요해보입니다.

팀 협업, 코드 리뷰가 필요한 과제/프로젝트라면 브랜치를 새로 딴 후 main에 push -> PR 생성 -> 리뷰 -> github PR에서 Merge 완료 -> 로컬의 main 브랜치에서 pull(원격 저장소와 동기화) -> merge된 브랜치 삭제 흐름으로 가는 것이 표준입니다.

<br>

rebase:

    base 브랜치 HEAD 위에 합치려는 브랜치의 커밋 기록을 쌓아 HEAD가 최신 커밋을 가리키는 방법입니다.

    1. 합치려는(base 위로 쌓일 예정인) 브랜치로 checkout
    2. git rebase <base를 가진 브랜치 이름(주로 main)>