---
layout: single
title:  "내가 보려고 정리한 git 명령어, 사용법"
folder: "git"
categories:
  - git
permalink: categories/git/1
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

<br><br>

배우는대로 계속 추가 예정

<br>

작업 상태(변경 여부) 확인 :

    git status

<br>

변경된 파일 스테이징 :

    git add [filename]

<br>

변경된 모든 파일 스테이징 :

    git add .

하나의 커밋 단위로 묶이게 되어, 커밋 메시지가 일괄로 전송됩니다. 따라서 커밋을 세분화해야 할 때에는 사용하지 않습니다.

<br>

스테이징 취소 :

    git rm --cached [filename]

.gitignore에 filename을 추가 후 해당 명령어를 사용하면, 다음 커밋부터는 깃이 해당 파일을 추적하지 않습니다.

git은 3가지 작업 단계를 가집니다. workdir, index(stage), HEAD입니다.

add, commit은 workdir -> index, index -> HEAD로 파일을 \'복사\' 후 기록합니다. 따라서 과거에 커밋된 파일은 그 기록은 지우지 못하지만, .gitignore + rm --cached 명령어를 사용하면 index에 복사된 파일을 지우게 됩니다(unstage). 따라서 이후 커밋에서부터는 해당 파일이 커밋되지 않는 것입니다.

<br>

커밋 :

    git commit -m "message"

<br>

Conventional Commit Style :

    feat: 새로운 기능 추가
    fix: 버그 수정
    docs: 문서 관련 수정
    style: 코드 동작에 영향 없이 코드스타일 수정
    refactor: 리팩터링
    test: 테스트 코드 추가, 수정, 삭제
    chore: .gitignore, 패키지 정리 등 잡무
    build: 빌드 시스템, 의존성 관련 변경
    revert: 이전 커밋 되돌리기

앞서 언급한 것처럼 커밋의 성격이 다르다면 add, commit을 각각 따로 실행합니다. 어처피 원격에 저장하는 작업은 한번에 진행하면 됩니다.

<br>

커밋 기록 조회 :

    git log

<br>

브랜치 생성하기 :

    git branch <브랜치 이름>

<br>

브랜치 목록 :

    git branch

<br>

브랜치 이름 변경하기 :

    git branch -m <기존 브랜치 이름> <새 브랜치 이름>

<br>

-m 대신 -M을 사용하면 강제로 이름을 변경합니다. 하지만 이는 무지성으로 덮어씌우는 꼴이므로, 가급적 -m을 사용하되 이름이 겹친다는 에러를 안전하게 받고 수정하는 것이 좋은 선택입니다.

<br>

다른 브랜치로 변경하기 :

    git checkout <브랜치 이름>

<br>

없던 브랜치를 생성하면서 변경하기 :

    git checkout -b <브랜치 이름>

<br>

브랜치 삭제 :

    안전 삭제 : git branch -d <브랜치 이름>

    강제 삭제 : git branch -D <브랜치 이름>

-d는 standard branch(처음 생성된 브랜치. 주로 main)에 병합되지 않은 브랜치는 삭제되지 않습니다. 이 역시 -D보다 안전하고 좋은 선택입니다.

<br>

Merge 후 로컬에서 원격(github origin)에 남아있는 브랜치 삭제하기 :

    git push <원격 저장소 이름. 주로 origin> --delete <삭제할 브랜치 이름>

<br>

원격 저장소 조회하기 :

    git remote -v(url 표시 옵션)

<br>

원격 저장소에 연결 추가하기 :

    git remote add <원격 저장소 이름(보통 origin)> <원격 저장소 url>

<br>

원격 저장소에 연결 해제하기 :

    git remote rm <원격 저장소 이름> <원격 저장소 주소>

<br>

로컬의 내용을 원격 저장소에 푸시하기 :

    git push -u <원격 저장소 이름> <로컬 브랜치 이름>

<br>

로컬의 커밋 기록을 처음 원격에 연결하고 push하기 :

    1. github 원격 저장소를 생성한다
    2. 로컬에서 git remote add origin <원격 저장소 주소>
    3. git branch -M <로컬의 첫 브랜치 이름(주로 main)>
    4. git push -u origin <로컬 브랜치 이름>

첫 push는 main 브랜치에서 진행하는 것이 일반적입니다.

<br>

원격 저장소의 내용을 로컬로 가져와 덮어씌우기 :

    git pull <원격 저장소 이름> <로컬 브랜치 이름>

<br>

원격 저장소의 내용을 로컬로 가져오기만 하기 :

    git fetch <원격 저장소 이름>

로컬의 파일은 영항받지 않습니다. FETCH_HEAD로 원격 저장소의 main 브랜치의 해시를 가져와 비교할 수 있으며, 이것을 토대로 수정 가능합니다.

<br>

원격 저장소 클론하기 :

    git clone <원격 저장소 url>

github에서 windows는 HTTPS, mac은 **SSH**로 url을 복사해야 합니다.

<br>

커밋 되돌리기 1 :

    git reset --hard HEAD^ 
    -> 마지막 커밋 자체를 삭제하고, 작업 디렉토리/스테이징도 그 이전 커밋 상태로 맞춥니다.
        (위험! 마지막 커밋 내용과 변경 사항 전부 사라짐)

    git reset --mixed HEAD^ (# 기본값)
    -> 마지막 커밋을 삭제하지만, 변경된 내용은 작업 디렉토리(workdir)에 "수정됨" 상태로 남습니다.
        (index(스테이징)은 비워짐)

    git reset --soft HEAD^
    -> 마지막 커밋을 삭제하고, 그 커밋 내용이 그대로 index(staging area)에 올라간 상태로 남습니다.
        (커밋 메시지만 다시 쓰고 싶을 때 유용)

HEAD는 최신 커밋, ^는 하나, ^^는 2개 이전 커밋을 가리킵니다.

<br>

커밋 되돌리기 2 :

    git revert <되돌아가고 싶은 커밋 해시>

git reset은 되돌린 버전 이후의 버전들이 모두 사라지게 되지만, git revert는 되돌린 버전 이후의 버전들은 모두 유지되고, revert되었다는 사실을 담은 commit이 새로 추가되는 방식입니다.

<br>

현재 수정 사항(변경점) 확인 :

    git diff <A commit hash> <B commit hash>
    (A 커밋에 비해 B 커밋은 무엇이 달라졌나?)

    git diff HEAD^ HEAD
    (전전 커밋에 비해 직전 커밋은 무엇이 달라졌나? ^의 수에 따라 여러 비교 가능)

    git diff HEAD
    (현재 작업 디렉토리 수정내용을 직전 커밋과 비교 후 출력)

<br>

병합하기 :

    1. 병합의 결과가 되는 브랜치로 checkout
    2. git merge <합치려는 브랜치 이름>
    3. conflict 발생 시, 직접 수정 후 add -> commit 수행(both modified가 되며, 자동으로 merge됩니다)

언제 PR을 쓰고, 언제 그냥 merge만 해도 될까? 

혼자 하는 토이 프로젝트, 연습이라면 그냥 git checkout main && git merge my_branch && git push 정도면 충분합니다. 굳이 my_branch에서 main으로 PR은 불필요해보입니다.

팀 협업, 코드 리뷰가 필요한 과제/프로젝트라면 브랜치를 새로 딴 후 main에 push -> PR 생성 -> 리뷰 -> github PR에서 Merge 완료 -> 로컬의 main 브랜치에서 pull(원격 저장소와 동기화) -> merge된 브랜치 삭제 흐름으로 가는 것이 표준입니다.

<br>

rebase:

    base 브랜치 HEAD 위에 합치려는 브랜치의 커밋 기록을 쌓아 HEAD가 최신 커밋을 가리키는 방법입니다.

    1. 합치려는(base 위로 쌓일 예정인) 브랜치로 checkout
    2. git rebase <base를 가진 브랜치 이름(주로 main)>