---
layout: single
title:  "메모리 분할 기법"
folder: "os"
categories:
  - operatingsystem
permalink: categories/operatingsystem/8
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

<br><br>

## 메모리 분할 방식 개요
물리적인 메모리(RAM)의 크기에 상관없이 프로세스가 실행될 수 있도록 공간을 지원하는 기술을 가상 메모리(Virtual Memory)라고 한다. 물리 메모리와 하드 디스크의 스왑 영역을 합쳐서 가상 주소 공간을 할당한 후, 실제 물리 메모리 주소와 일대일로 대응되는 매핑 테이블을 생성하여 물리 메모리보다 크기가 큰 프로세스를 조각화한 후 실행시키는 방법이다.

CPU 스케줄러의 시분할 방식은 실제로 프로세스가 동시에 실행되는 것이 아니라 프로세스의 실행 시간을 타임 슬라이스를 통해 분할한 후 빠른 문맥 교환을 거쳐 마치 동시에 실행되는듯한 착각을 불러일으키는 방법이다. 이와 비슷하게 가상 메모리에서 프로세스를 적절히 분할하여 실행 중인 일부만 메모리에 올려두는 것을 메모리 오버레이(Memory Overlay), 나머지는 스왑 영역에서 대기하여 스왑 인, 스왑 아웃 과정을 거쳐 전체 프로세스를 실행시키는 원리를 스와핑(Swapping)이라고 한다.

물리 메모리를 분할하는 방식에는 고정 분할 기법을 사용한 페이징(Paging) 기법과 프로세스 크기별로 분할하는 세그먼테이션(Segmentation) 기법이 있다. 각 기법은 장단점이 있으며, 오늘날에는 두 기법의 장점만을 가진 세그먼테이션-페이징 혼용 기법이 주로 사용되고 있다.

## 페이징 기법
페이징 기법은 물리 주소 공간을 일정한 크기로 나누어 사용한다. 가상 주소 공간과 물리 주소 공간을 분할하는 페이지의 크기가 같으며, 페이지 테이블에 의해 일대일로 매핑된다. 모든 프로세스가 예외 없이 고정적인 간격으로 분할되어 물리 메모리 입장에서는 공간을 효율적으로 사용할 수 있지만, 내부 단편화 문제가 발생할 수 있으며 실행되는 프로세스에 의해 생성되는 가상 주소 공간이 커짐에 따라 페이지 테이블의 크기도 비례하여 증가한다는 단점이 있다.

페이지 테이블은 운영체제가 관리하기 때문에 일반적으로 메모리의 커널 영역에 저장되는 데이터베이스이다. 따라서 테이블의 크기가 너무 커져버리게 되면 전체 메모리 중 실제 사용자 프로세스가 적재될 수 있는 사용자 메모리 영역이 줄어들게 된다. 이에 운영체제는 페이지 테이블을 스왑 영역으로 옮겨서 관리할 수 있는 방식을 제공한다. 페이지 테이블의 저장 위치와 매핑 방식에 따라 직접 매핑, 연관 매핑, 집합-연관 매핑, 역 매핑으로 나눌 수 있다.

직접 매핑은 페이지 테이블이 전부 커널 영역에 저장된 방식이다. 시스템 호출을 통해 메모리 내 테이블에 바로 접근할 수 있어 O(1)의 속도로 데이터를 찾을 수 있다. 하지만 페이지 테이블이 커질수록 사용자 메모리가 줄어드는 단점이 존재한다.

연관 매핑은 페이지 테이블이 전부 스왑 영역에 저장된 방식으로, 일부 레코드를 무작위로 뽑아 변환 색인 버퍼(Translation Lookaside Buffer)를 형성한 후 매핑을 진행한다. 변환 색인 버퍼는 기존의 페이지 테이블처럼 주소가 차례로 연결된 자료구조가 아니기 때문에 데이터 탐색에 O(N)의 속도가 걸린다. 심지어 버퍼에 원하는 데이터가 없을 경우(TLB 미스), 스왑 영역으로 내려가 전체 테이블을 탐색한다.

페이지 테이블 전체가 스왑 영역에 있으므로 사용할 수 있는 사용자 영역은 늘어나지만, 직접 매핑에 비해 탐색 시간이 매우 느리다는 단점이 있다.

집합-연관 매핑은 스왑 영역에 저장된 페이지 테이블을 일정 구간의 집합으로 묶어서 관리하는 방식이다. 현재 메모리에 올라와 있는 부분이 포함된 집합을 선택하여 데이터를 매우 빠른 속도 O(1)으로 찾을 수 있다. 집합 테이블을 커널 영역에 추가적으로 생성해야 하는 단점이 있지만 사용자 영역을 충분히 확보함과 동시에 데이터 접근 속도까지 챙길 수 있는 매핑 방식이다.

역 매핑은 가상 주소의 분할 단위인 페이지가 아닌 현재 적재 중인 물리 주소의 프레임을 기준 인덱스로 테이블을 생성하는 기법이다. 역 매핑의 페이지 테이블은 각 프레임을 차지하는 프로세스 아이디(PID)와 페이지 번호로 테이블이 구성되기 때문에 가상 공간에 속한 프로세스의 수와 상관없이 테이블의 크기가 일정하게 유지된다. 하지만 연관 매핑처럼 페이지 테이블 전체를 살펴 프로세스를 확인해야 하므로 데이터 검색에 취약하다.

## 세그먼테이션-페이징 혼용 기법
세그먼테이션 기법은 물리 주소 공간을 프로세스의 크기대로 나누어 사용한다. 메모리를 프로세스 단위로 할당했기 때문에 매핑 테이블이 작고 단순하다는 장점이 있지만, 심각한 외부 단편화 문제가 발생한다.

세그먼테이션-페이징 혼용 기법은 코드, 데이터, 스택 영역으로 나뉘는 프로세스의 각 영역마다 주어진 메모리 접근 권한(읽기, 쓰기, 실행)을 비트로 표시하는 권한 비트를 추가로 사용한다. 권한 비트를 통해 해당 프로세스의 세그먼트 번호로 가서 자신의 영역을 벗어나는 페이지인지, 권한이 없는 페이지에 접근하는 것은 아닌지 우선적으로 확인한 후, 매핑을 진행하는 방식이다.

정리하면 세그먼테이션-페이징 혼용 기법은 기존의 세그먼테이션 테이블에 권한 비트를 추가하여 메모리 오류(트랩)를 우선적으로 세그먼테이션 테이블에서 검사한 후, 좁아진 범위 내에서 집합-연관 매핑 방식으로 생성된 페이지 테이블을 통해 작업을 처리하는 방식이다.

## 페이지 교체 알고리즘
필요한 프로세스 페이지가 메모리에 없는 상황을 페이지 부재(Page Fault)라고 하며, 페이지 테이블을 활용해 매핑 후 스왑 영역에서 해당 페이지를 메모리로 가져와야 한다. 이를 요구 페이징이라고 한다.

물리 메모리에 빈 프레임이 없을 때에는 메모리 내 프레임 중 하나를 스왑 영역으로 내보내야 하는데, 어떤 페이지를 스왑 영역으로 내보낼지 결정하는 알고리즘을 페이지 교체 알고리즘이라고 한다. 이때 알고리즘을 통해 교체 대상이 될 페이지를 대상 페이지라고 한다.

무작위 페이지 교체 알고리즘은 대상 페이지를 무작위로 선정한다. 아무런 기준이 없으므로 알고리즘 성능이 좋지 않아 거의 사용하지 않는다.

FIFO 페이지 교체 알고리즘은 시간상으로 가장 먼저 들어온 페이지가 가장 먼저 나가는 알고리즘이다. 무작위 알고리즘보다는 합리적이지만 메모리에 먼저 들어왔어도 자주 사용되는 페이지가 있기도 하고, 나중에 들어왔어도 한 번만 사용되는 페이지가 있는 등의 여러 상황을 고려하지 않고 무조건 선입선출(First In First Out) 방식으로 동작하기 때문에 이 또한 성능이 좋은 편은 아니다.

최적 페이지 교체 알고리즘은 미래에 사용될 페이지를 남겨두는 알고리즘이다. 이론적으로는 완벽하지만 미래를 알 수 없기 때문에 실제 구현은 불가능하다.

LRU 페이지 교체 알고리즘은 가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정한다.

LFU 페이지 교체 알고리즘은 가장 적게 사용한 페이지를 교체한다.

NUR 페이지 교체 알고리즘은 페이지 테이블의 플래그 비트 중 참조, 변경 비트를 사용한 방식이다. 참조나 변경을 했을 경우 비트 값을 변경한 후 전체 페이지 중 계산된 비트 값이 가장 낮은 페이지를 대상 페이지로 선정한다.

LRU, LFU, NUR 알고리즘을 묶어서 최적 근접 알고리즘이라 부른다.

2차 기회 페이지 교체 알고리즘은 FIFO 알고리즘에서 성공한 페이지를 대상 페이지로 지정해 스왑 영역으로 보내는 것이 아니라, 다시 FIFO 페이지 큐의 맨 뒤로 넣는 방식이다. 기존의 FIFO보다 자주 사용할 페이지를 좀 더 논리적으로 겨냥한 방식이라고 할 수 있다.

시계 알고리즘은 페이지를 가리키는 포인터와 참조 비트를 사용해 대상 페이지를 선정하는 알고리즘이다. 포인터가 가리키는 페이지가 우선적으로 대상 페이지가 되며, 메모리에 페이지가 있다면 해당 페이지를 참조한 후 참조 비트를 1로 변경한다.

만약 포인터가 가리키는 대상 페이지의 비트가 1이라면 비트를 즉시 0으로 바꾸고 다음 페이지로 포인터를 건너뛰어 해당 페이지에 대한 기회를 한 번 더 제공한다.

포인터가 최하단을 가리키게 되면 원형으로 돌려 다시 최상단으로 포인터를 변경 후 대상 페이지 선정을 계속 진행한다.