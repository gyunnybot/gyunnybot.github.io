---
layout: single
title:  "메모리 분할 기법"
folder: "os"
categories:
  - operatingsystem
permalink: categories/operatingsystem/8
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 메모리 분할 방식 개요
메모리(RAM) 크기에 상관없이 프로세스가 실행될 수 있도록 공간을 지원하는 기술을 가상 메모리(Virtual Memory)라고 한다. 가상 메모리는 프로세스마다 독립적인 가상(이하 논리) 주소 공간을 제공하고, 페이지 테이블(Page Table)을 통해 논리 주소를 물리 주소로 매핑한다. 이때 필요한 페이지만 물리 메모리에 적재하고 나머지는 디스크(백킹 스토어/스왑 영역)에 둠으로서 실제 물리 메모리보다 큰 주소 공간을 가지는 프로세스도 실행 가능하도록 만드는 기술이다.

CPU 스케줄러의 시분할 방식은 실제로 프로세스가 동시에 실행되는 것이 아니라, 프로세스의 실행 시간을 타임 슬라이스를 통해 분할한 후 빠른 문맥 교환을 거쳐 마치 동시에 실행되는듯한 착각을 불러일으키는 방법이다. 이와 비슷하게 가상 메모리에서도 프로세스의 주소 공간을 적절히 분할(페이징)하여 실행 중인 일부 페이지만 메모리에 올려두고 나머지는 디스크에 두었다가 필요할 때 가져오는 방식으로 동작한다. 과거에는 프로그램을 사람이 직접 분할해 필요한 부분만 번갈아 적재하는 메모리 오버레이(Memory Overlay) 기법이 사용되기도 했지만, 현대 운영체제에서는 주로 요구 페이징(Demand Paging)을 통해 이러한 동작이 자동으로 처리된다. 또한 페이지를 교환하는 개념인 스와핑(Swapping)은 프로세스 전체 또는 페이지 단위의 디스크와 메모리 사이의 교체만을 의미했지만, 현대 가상 메모리 환경에서는 보통 페이지 단위로 메모리와 디스크 사이를 교환하는 흐름까지 포함하는 개념으로 확장되었다.

물리 메모리를 분할하는 방식에는 고정 분할 기법을 사용한 페이징(Paging) 기법과, 프로세스가 차지하는 논리 주소 공간으로 나누는 세그먼테이션(Segmentation) 기법이 있다. 각 기법은 장단점이 있으며, 오늘날에는 하드웨어/운영체제 구조에 따라 두 아이디어가 결합된 세그먼테이션-페이징 혼용 기법(세그먼트 기반 보호 + 페이징 기반 적재)이 일반적으로 사용된다.

## 페이징 기법
페이징 기법은 물리 주소 공간을 일정한 크기인 프레임(frame)으로 나누어 사용한다. 논리 주소 공간을 분할하는 페이지(page)의 크기와 프레임의 크기가 같으며, 페이지가 들어갈 프레임 공간이 페이지 테이블에 의해 매핑된다. 이 방식은 고정 크기 단위로 메모리를 관리하므로 외부 단편화가 발생하지 않는 장점이 있지만, 페이지 단위 특성상 내부 단편화가 발생할 수 있으며 여러 개의 프로세스를 띄우거나 프로세스의 논리 주소 공간이 커질수록 커널이 관리하는 페이지 테이블의 규모도 비례하여 증가한다는 단점이 있다. 페이지 테이블은 각 프로세스마다 독립적으로 하나씩 생성되기 때문이다.

페이지 테이블은 운영체제가 관리하는 자료구조로, 일반적으로 메모리에 상주하며 커널이 이를 관리한다. 앞서 말했듯 프로세스마다 페이지 테이블이 필요하기 때문에, 주소 공간이 크거나 프로세스 수가 많아질수록 메모리 사용량 부담이 늘어날 수 있다. 이를 완화하기 위해 운영체제는 다단계(Multi-Level) 페이지 테이블, 해시 기반 페이지 테이블, 역(inverted) 페이지 테이블 등의 구조를 사용한다.

또한 페이징 기법에서는 빠른 주소 변환을 위해 일반적으로 변환 색인 버퍼(Translation Lookaside Buffer, TLB)를 함께 사용한다. TLB는 페이지 테이블의 일부 변환 정보를 캐시하는 하드웨어 구조로, 연관 탐색(병렬 비교)을 통해 매우 빠르게 조회한다. TLB에 원하는 변환 정보가 없을 경우(TLB 미스), 하드웨어/운영체제는 보통 메모리에 있는 페이지 테이블을 따라가거나(page walk), 구조에 따라 해시 탐색 등을 통해 변환 정보를 찾아 TLB를 갱신한다. 하드웨어 레벨에서의 디스크 접근은 페이지 테이블을 탐색하는 과정에서 발생하는 것이 아니라, 해당 페이지가 메모리에 없을 때(페이지 폴트) 디스크에서 페이지를 가져와야 하는 상황에서 한 번 발생한다.

페이지 테이블 구조 중 특별히 역 매핑(inverted page table)은 논리 주소의 분할 단위인 페이지가 아닌, 현재 실제로 적재 중인 물리 주소의 프레임을 기준 인덱스로 테이블을 생성하는 기법이다. 역 매핑 페이지 테이블은 각 프레임을 차지하는 프로세스 아이디(PID)와 페이지 번호로 구성되기 때문에 프로세스 수나 논리 주소 공간 크기에 비해 테이블 크기가 상대적으로 일정하게 유지될 수 있다는 장점이 있다. 그러나 원하는 (PID, page)에 해당하는 항목을 찾기 위해 해시 등의 추가 테이블 구조가 필요하거나 탐색 비용이 발생할 수 있다.

## 세그먼테이션-페이징 혼용 기법
세그먼테이션 기법은 프로세스의 논리 주소 공간을 코드, 데이터, 스택과 같은 의미 단위의 세그먼트로 나누어 관리한다. 논리 주소는 (세그먼트 번호, 오프셋) 형태로 표현되며, 세그먼트 테이블은 각 세그먼트의 base/limit(범위) 및 보호(권한) 정보를 통해 접근 범위/권한을 검사하고 물리 주소 변환에 필요한 기반 정보를 제공한다. 세그먼테이션은 논리적 구획과 보호를 표현하기 쉽지만, 가변 크기 할당 특성상 외부 단편화 문제가 발생할 수 있다.

세그먼테이션-페이징 혼용 기법은 보통 세그먼트 단위로 접근 권한(읽기/쓰기/실행)과 범위를 먼저 검사해 잘못된 접근을 트랩으로 판별한 뒤, 해당 세그먼트 내부를 다시 페이지 단위로 나누어 페이지 테이블을 통해 페이지-프레임 변환을 수행하는 2단계 주소 변환 방식이다. 즉, 세그먼트 테이블에서 보호/범위를 확인하고, 그 결과로 얻은 페이지 테이블(또는 관련 정보)을 이용해 최종 물리 주소를 계산한다.

## 페이지 교체 알고리즘
필요한 프로세스 페이지가 메모리에 없는 상황을 페이지 부재(Page Fault)라고 하며, 이 경우 운영체제는 해당 페이지를 디스크에서 메모리로 가져와야 한다(요구 페이징). 물리 메모리에 빈 프레임이 없을 때에는 메모리 내 프레임 중 하나를 디스크로 내보내야 하는데, 어떤 페이지를 내보낼지 결정하는 알고리즘을 페이지 교체 알고리즘이라고 한다. 이때 알고리즘을 통해 교체 대상이 될 페이지를 대상 페이지라고 한다.

무작위 페이지 교체 알고리즘은 대상 페이지를 무작위로 선정한다. 아무런 기준이 없으므로 알고리즘 성능이 좋지 않아 거의 사용하지 않는다.

FIFO 페이지 교체 알고리즘은 시간상으로 가장 먼저 들어온 페이지가 가장 먼저 나가는 알고리즘이다. 무작위 알고리즘보다는 합리적이지만 메모리에 먼저 들어왔어도 자주 사용되는 페이지가 있기도 하고, 나중에 들어왔어도 한 번만 사용되는 페이지가 있는 등의 여러 상황을 고려하지 않고 무조건 선입선출(First In First Out) 방식으로 동작하기 때문에 이 또한 성능이 좋은 편은 아니다.

최적 페이지 교체 알고리즘은 미래에 사용될 페이지를 남겨두는 알고리즘이다. 이론적으로는 완벽하지만 미래를 알 수 없기 때문에 실제 구현은 불가능하다.

LRU 페이지 교체 알고리즘은 가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정한다.

LFU 페이지 교체 알고리즘은 가장 적게 사용한 페이지를 교체한다.

NUR 페이지 교체 알고리즘은 페이지 테이블의 플래그 비트 중 참조, 변경 비트를 사용한 방식이다. 참조나 변경을 했을 경우 비트 값을 변경한 후 전체 페이지 중 계산된 비트 값이 가장 낮은 페이지를 대상 페이지로 선정한다.

LRU, LFU, NUR 알고리즘을 묶어서 최적 근접 알고리즘이라 부른다.

2차 기회 페이지 교체 알고리즘은 FIFO 알고리즘에서 대상 페이지를 바로 내보내는 것이 아니라, 참조 비트를 확인해 최근에 참조된 페이지라면 한 번 기회를 주고(비트를 0으로 바꾸고) 큐의 뒤로 보내는 방식이다. 기존 FIFO보다 자주 사용할 페이지를 좀 더 논리적으로 겨냥한 방식이라고 할 수 있다.

시계(Clock) 알고리즘은 페이지를 가리키는 포인터와 참조 비트를 사용해 대상 페이지를 선정하는 알고리즘이다. 포인터가 가리키는 페이지가 우선적으로 후보가 되며, 참조 비트가 1이면 비트를 0으로 바꾸고 다음 페이지로 넘어가 기회를 한 번 더 제공한다. 포인터가 끝까지 가면 원형으로 다시 돌아가며, 참조 비트가 0인 페이지를 만났을 때 그 페이지를 교체 대상으로 선정한다.