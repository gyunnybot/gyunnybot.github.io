---
layout: single
title:  "프로세스 동기화"
folder: "os"
categories:
  - operatingsystem
tags: OS
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

<span style="color: rgb(3, 150, 150); font-weight: bold;">`P()`</span>

## 임계구역, 세마포어와 모니터
여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`공유 자원(shared resource)`</span>이라고 합니다. 공유 자원은 이름처럼 공동으로 사용되기 때문에 프로세스 접근 순서에 따라 실행 결과가 달라지는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`경쟁 조건(race condition, 동시성 문제)`</span>이 발생할 수 있습니다.

공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 코드 영역을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`임계구역(critical section)`</span>이라고 합니다. 따라서 경쟁 조건은 임계 구역 안에서 발생합니다.

임계구역 해결 조건은 크게 세 가지가 있으며 모두 만족해야만 경쟁 조건을 막을 수 있습니다.

	1. 상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없습니다.
    
    2. 한정 대기: 임계구역에 들어가지 못한 프로세스가 계속 기다려서는 안됩니다.
    
	3. 진행의 융퉁성: 비어있는 임계구역에 프로세스가 들어가는 것을 방해해서는 안됩니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`세마포어(semaphore)`</span>는 임계구역 문제를 해결하기 위한 방법 중 변수 자원에 대한 바쁜 대기를 하지 않는 간단한 방법입니다. <span style="color: rgb(3, 150, 150); font-weight: bold;">`Semaphore()`</span>로 현재 사용 가능한 자원의 수를 선언 후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`P()`</span>와 <span style="color: rgb(3, 150, 150); font-weight: bold;">`V()`</span>함수를 통해 임계구역을 통제합니다.

```c
  int RS; //현재 사용 가능한 자원의 수

  void Semaphore(int n){
    RS = n
  }

  void P(){
    if(RS > 0){
      RS -= 1;
    }
    else{
      block(); //until RS > 0
    }
  }

  void V(){
    RS += 1;
    wake_up(); //process signal
  }

  int main(){
    int n = 0;

    cin >> n;

    Semaphore(n);

    P();

    /*------
    임계구역
    ------*/

    V();

    return 0;
  }
```

<span style="color: rgb(3, 150, 150); font-weight: bold;">`인터페이스(Interface)`</span>
세마포어 방식 또한 실행 도중 다른 코드가 실행된다면 임계구역 문제를 해결할 수 없습니다. 따라서 세마포어 전체 코드는 하드웨어가 지원하는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`검사와 지정(test-and-set)`</span>을 통해 프로세스가 통째로 실행되어야 합니다.

세마포어 방식의 가장 큰 문제는 P(), V() 함수의 잘못된 사용으로 상호 배제와 한정 대기를 만족하지 못할 수 있습니다. <span style="color: rgb(3, 150, 150); font-weight: bold;">`모니터`</span> 방식은 사용자에게 함수를 제공하여 임계구역을 직접 제어하는 것이 아니라 공유 자원에 접근하기 위한 <span style="color: rgb(3, 150, 150); font-weight: bold;">`인터페이스(Interface)`</span>만을 제공하고 임계구역 처리는 내부적으로 진행하여 문제를 해결하는 방식입니다. 임계구역 내 다른 프로세스의 개입을 피하기 위해 모니터 방식은 모니터 큐에 올라온 인터페이스 호출(넓은 의미의 시스템 호출)만을 순차적으로 처리합니다. 임계 구역의 보호와 프로세스와의 동기화 모두 모니터 내부에서 처리되므로 사용자는 필요 시 인터페이스만 호출하기만 하면 됩니다. 해당 방식은 오늘날의 객체지향 프로그래밍 방식과 매우 유사합니다.

```java
  struct condition{
    boolean wait(){ //P() in Semaphore
      //...
    }

    boolean singal(){ //V() in Semaphore
      //...
    }
  }

  monitor shared_balance{
    private:
      int balance = 10;
      boolean busy = false;
      condition mon; //상태 변수

    public:
      increase(int amount){
        if(busy == true){
          mon.wait();
        }

        busy = true;
        balance = balance + amount;

        mon.signal();
      }
  }
```

## 소켓 프로그래밍
