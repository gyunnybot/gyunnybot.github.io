---
layout: single
title:  "프로세스 동기화"
folder: "os"
categories:
  - operatingsystem
tags: OS
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 임계구역 해결 방법
여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`공유 자원(shared resource)`</span>이라고 합니다. 공유 자원은 이름처럼 공동으로 사용되기 때문에 프로세스 접근 순서에 따라 실행 결과가 달라지는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`경쟁 조건(race condition, 동시성 문제)`</span>이 발생할 수 있습니다.

공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 코드 영역을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`임계구역(critical section)`</span>으로 부릅니다. 경쟁 조건은 임계 구역 안에서 발생합니다.

임계구역 해결 조건은 크게 세 가지가 있으며 모두 만족해야만 경쟁 조건을 막을 수 있습니다.

	1. 상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없습니다.
    
    2. 한정 대기: 임계구역에 들어가려는 프로세스가 무한히 대기하지 않아야 합니다.
    
	3. 진행의 융통성: 비어 있는 임계구역에는 프로세스가 방해받지 않고 접근할 수 있어야 합니다.

<br>
<span style="color: rgb(3, 150, 150); font-weight: bold;">`세마포어(semaphore)`</span>는 임계구역 해결 방법 중 변수 자원에 대한 바쁜 대기를 하지 않는 간단한 방법입니다. <span style="color: rgb(3, 150, 150); font-weight: bold;">`Semaphore()`</span>로 현재 사용 가능한 자원의 수를 선언 후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`P()`</span>와 <span style="color: rgb(3, 150, 150); font-weight: bold;">`V()`</span> 함수를 통해 임계구역을 통제합니다.
<br>

```c
  int RS; //현재 사용 가능한 자원의 수

  void Semaphore(int n){
    RS = n
  }

  void P(){
    if(RS > 0){
      RS -= 1;
    }
    else{
      block(); //until RS > 0
    }
  }

  void V(){
    RS += 1;
    wake_up(); //process signal
  }

  int main(){
    int n = 0;

    cin >> n;

    Semaphore(n);

    P();

    /*------
    임계구역
    ------*/

    V();

    return 0;
  }
```

<br>
세마포어 방식 또한 실행 도중 다른 코드가 실행된다면 임계구역 문제를 해결할 수 없습니다. 따라서 세마포어 전체 코드는 하드웨어가 지원하는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`검사와 지정(test-and-set)`</span>을 사용해 프로세스가 통째로 실행되도록 해야 합니다.

세마포어 방식의 가장 큰 문제는 P(), V() 함수의 잘못된 사용으로 상호 배제와 한정 대기를 만족하지 못해 동기화 문제가 발생할 수 있습니다. 또한 앞선 설명처럼 하드웨어 지원 없이 원자성을 보장하기 어려운 경우가 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`모니터`</span> 방식은 공유 자원 접근을 위한 <span style="color: rgb(3, 150, 150); font-weight: bold;">`인터페이스(Interface)`</span>만을 제공하고 동기화와 상호 배제는 내부적으로 처리하는 방식입니다. 이는 세마포어 방식에서의 사용자 실수를 방지하고, 코드의 추상화를 높여 안정성을 제공합니다.

모니터 방식은 모니터 큐에 올라온 인터페이스 호출(넓은 의미의 시스템 호출)만을 순차적으로 처리하여 임계구역 내 다른 프로세스의 개입을 피합니다. 임계 구역 보호와 프로세스와의 동기화 모두 모니터 내부에서 처리되므로 사용자는 인터페이스만 호출해 동기화를 수행하 수 있습니다. 해당 방식은 오늘날의 객체지향 프로그래밍 방식과 매우 유사합니다.

```java
  struct condition{
    boolean wait(){ //P() in Semaphore
      //...
    }

    boolean singal(){ //V() in Semaphore
      //...
    }
  }

  monitor shared_balance{
    private:
      int balance = 10;
      boolean busy = false;
      condition mon; //상태 변수

    public:
      increase(int amount){
        if(busy == true){
          mon.wait();
        }

        busy = true;
        balance = balance + amount;

        mon.signal();
        busy = false; //플래그를 해제하여 다른 프로세스가 접근 가능하게 만듭니다
      }
  }
```

## 소켓 프로그래밍
여러 컴퓨터에 있는 프로세스 간 통신을 네트워킹이라고 하며, 일반적으로 소켓을 활용하기 때문에 소켓 프로그래밍이라고도 불립니다. 소켓은 프로세스 간 양방향 통신과 동기화를 지원합니다.

클라이언트는 소켓을 생성한 후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`connect()`</span>를 사용해 서버와의 접속을 시도합니다. 이후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`read()`</span>와 <span style="color: rgb(3, 150, 150); font-weight: bold;">`write()`</span>를 활용해 통신 후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`close()`</span>로 접속을 종료합니다.

서버는 소켓을 생성 후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`bind()`</span>를 통해 특정 포트에 등록합니다. 이후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`listen()`</span>을 실행하여 클라이언트를 받을 준비를 한 후 <span style="color: rgb(3, 150, 150); font-weight: bold;">`accept()`</span>를 통해 여러 클라이언트가 요청한 connect() 중 하나를 선택해 본인의 소켓과 연결합니다. 이후 read(), write()를 통해 통신 후 close()를 통해 클라이언트와의 접속을 종료합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`클라이언트 코드`</span>

```c
  #include<sys/types.h>
  #include<sys/socket.h>
  #include<netinet/in.h>
  #include<netdb.h>

  void main(){
    int sp; //소켓 기술자 sp
    char buf[5];
    struct sockaddr_in ad;

    sp = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

    memset(&ad, 0, sizeof(ad));

    ad.sin_family = AF_INET;
    ad.sin_addr.s_addr = inet_addr("127.0.0.1");
    ad.sin_port = htons(11234);

    connect(sp, (struct sockaddr *) &ad, sizeof(ad));

    read(sp, buf, s);
    printf("%s", buf);

    close(sp);
    
    return 0;
  }
```

<span style="color: rgb(3, 150, 150); font-weight: bold;">`서버 코드`</span>

```c
  #include<sys/types.h>
  #include<sys/socket.h>
  #include<netinet/in.h>
  #include<netdb.h>

  void main(){
    int sp, sa; //소켓 기술자 sa
    struct sockaddr_in ad;

    memset(&ad, 0, sizeof(ad));

    ad.sin_family = AF_INET;
    ad.sin_addr.s_addr = htonl(INADDR_ANY);
    ad.sin_port = htons(11234);

    sp = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    bind(sp, (struct sockaddr *) &ad, sizeof(ad));

    listen(sp, 10);

    while(true){
      sa = accept(sp, 0, 0);
      write(sa, "Test", 0);
      close(sa);
    }

    return 0;
  }
```

서버의 경우 클라이언트를 계속 받아 작업해야 하므로 무한 루프를 돌며 accept()를 통해 클라이언트를 받아 작업을 반복합니다.