---
layout: single
title:  "프로세스"
folder: "os"
categories:
  - operatingsystem
permalink: categories/operatingsystem/4
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

<br><br>

## 프로세스의 개념
저장장치에 저장된 프로그램을 실행시키면 프로세스가 된다. 정확히 말하면 프로그램이 CPU에 의해 실행되면서 해당 프로그램의 인스턴스가 메모리에 적재된 후 운영체제가 관리하게 된다. 이때 운영체제는 프로그램에 추가로 프로세스 구분자, 메모리 관련 정보, 레지스터와 같은 중간값을 담은 프로세스 제어 블록(Process Control Block)을 생성한다.

정리하면, 프로세스란 프로그램 코드와 이를 실행하기 위한 상태 정보(PCB)가 메모리에 적재되어 운영체제에 의해 관리되고 있는 프로그램의 인스턴스를 의미한다.

## fork(), exec()
fork() 시스템 호출로 실행 중인 프로세스를 복제하여 자식 프로세스를 생성할 수 있다. 부모-자식 프로세스를 구분할 수 있는 PID에 대한 정보만 바뀐 채, 모든 내용이 복사된다. 특이하게 fork()는 부모와 자식 프로세스에 각각 다른 반환값을 리턴한다. 부모 프로세스에서 fork()를 호출하면 자식 프로세스의 PID를 반환하고, 자식 프로세스에는 0을 반환한다.

exec()는 현재 프로세스의 메모리 공간을 새로운 프로그램으로 완전히 덮어쓰기 하는 시스템 호출이다. fork()로 생성된 자식 프로세스는 일반적으로 exec()를 통해 다른 프로세스로 변환된다. fork()에 의해 새로 부여받은 PID는 유지된 채로 프로세스의 코드, 데이터, 힙, 스택 등이 전부 교체 또는 초기화된다.

아래 코드는 리눅스/유닉스에서 새로운 프로그램을 실행하는 기본적인 방식으로, fork()로 생성된 자식 프로세스가 exec()로 /bin/ls를 실행한다.

```c
pid_t pid = fork();

if (pid == 0) {
    // 자식 프로세스에서 실행
    execl("/bin/ls", "ls", "-l", (char *)NULL);
} else {
    // 부모 프로세스에서 실행
    wait(NULL);
}
```

## 고아 프로세스, 좀비 프로세스
부모 프로세스가 먼저 종료되어 비정상적으로 남아 있는 자식 프로세스를 고아 프로세스(Orphan Process)라고 한다. 하지만 대부분의 운영체제는 이러한 프로세스를 자동으로 init 프로세스(리눅스에서는 PID 1)가 수거하여 관리하므로, 실제 시스템에서 고아 프로세스가 문제를 일으키는 경우는 거의 없다.

커널은 자식 프로세스가 종료되면 가상 메모리 공간, 소켓 등의 외부 자원은 즉시 반납하지만, PID 정보나 종료 코드처럼 OS가 관리해야 하는 최소한의 정보는 부모가 확인할 때까지 잠시 남겨 둔다. 이때 부모 프로세스가 wait() 계열 함수를 호출하지 않으면 해당 프로세스의 PID 정보가 프로세스 테이블에 남아 있는 상태가 되는데, 이를 좀비 프로세스(Zombie Process)라고 한다.

좀비 프로세스는 더 이상 CPU나 메모리를 차지하지는 않지만, PID가 회수되지 않으면 프로세스 테이블이 가득 차 새로운 프로세스 생성이 반려되는 문제가 발생할 수 있다. 이를 방지하기 위해 부모 프로세스는 wait()를 호출하여 커널이 자식 프로세스의 모든 종료 상태 데이터를 회수하도록 해야 한다.