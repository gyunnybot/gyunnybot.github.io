---
layout: single
title:  "메모리 관리"
folder: "os"
categories:
  - operatingsystem
permalink: categories/operatingsystem/os004
tags: OS
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 메모리 분할 방식 개요
물리적인 메모리(RAM)의 크기에 상관없이 프로세스가 실행될 수 있도록 공간을 지원하는 기술을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`가상 메모리`</span>라고 합니다. 물리 메모리와 하드 디스크의 스왑 영역을 합쳐서 가상 주소 공간을 할당한 후, 실제 물리 메모리 주소와 일대일로 대응되는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`매핑 테이블`</span>을 생성하여 물리 메모리보다 크기가 큰 프로세스를 실행시키는 방법입니다.

CPU 스케줄러의 시분할 방식은 실제로 프로세스가 동시에 실행되는 것이 아닌, 프로세스의 실행 시간을 타임 슬라이스 방식으로 분할하여 빠른 문맥 교환을 통해 마치 동시에 실행되는 착각을 불러일으키는 방법입니다. 이와 비슷하게 실행 중인 프로세스를 적절히 분할하여 일부만 메모리에 올려두는 것을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`메모리 오버레이`</span>, 나머지는 스왑 영역에서 대기하여 스왑 인, 스왑 아웃 과정을 거쳐 전체 프로세스를 실행시키는 원리를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`스와핑(Swapping)`</span>이라고 합니다.

물리 메모리를 분할하는 방식에는 고정 분할 기법을 사용한 <span style="color: rgb(3, 150, 150); font-weight: bold;">`페이징`</span> 기법과 프로세스 크기별로 분할하는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`세그먼테이션`</span> 기법이 있습니다. 각 기법은 장단점이 있으며, 오늘날에는 두 기법의 장점만을 가진 <span style="color: rgb(3, 150, 150); font-weight: bold;">`세그먼테이션-페이징 혼용`</span> 기법이 주로 사용되고 있습니다.

## 페이징 기법
페이징 기법은 물리 주소 공간을 일정한 크기로 나누어 사용합니다. 가상 주소 공간과 물리 주소 공간을 분할하는 페이지의 크기가 같으며, 페이지 테이블에 의해 **일대일로 매핑**됩니다. 하나의 프로세스라도 예외 없이 고정적인 간격으로 분할되므로 물리 메모리 입장에서는 공간을 효율적으로 사용할 수 있지만, 내부 단편화 문제가 발생할 수 있으며 실행되는 프로세스에 의해 생성되는 가상 주소 공간이 커짐에 따라 페이지 테이블의 크기도 비례하여 증가한다는 단점이 있습니다.

페이지 테이블은 운영체제가 관리하기 때문에 일반적으로 메모리의 커널 영역에 저장되는 데이터베이스입니다. 따라서 테이블의 크기가 너무 커져버리게 되면 전체 메모리 중 실제 사용자 프로세스가 적재될 수 있는 사용자 메모리 영역이 줄어들게 됩니다. 이때 운영체제는 사용할 수 있는 사용자 영역이 줄어들 경우를 대비해 페이지 테이블 또한 **스왑 영역**으로 옮겨서 관리할 수 있는 방식을 제공합니다. 페이지 테이블의 저장 위치와 매핑 방식에 따라 직접 매핑, 연관 매핑, 집합-연관 매핑, 역 매핑으로 나눌 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`직접 매핑`</span>은 커널 영역에 페이지 테이블이 전부 저장된 방식입니다. 시스템 호출을 통해 메모리 내 테이블에 바로 접근할 수 있어 O(1)의 속도로 데이터를 찾을 수 있습니다. 하지만 페이지 테이블이 커지게 된다면 사용자 영역이 줄어드는 단점이 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`연관 매핑`</span>은 페이지 테이블이 전부 스왑 영역에 저장된 방식으로 일부 레코드를 **무작위**로 뽑아 **변환 색인 버퍼(TLB)**를 형성한 후 매핑을 진행합니다. 변환 색인 버퍼는 기존의 페이지 테이블처럼 연결된 자료구조가 아니기 때문에 데이터 탐색에 O(N)의 속도가 걸립니다. 심지어 버퍼에 원하는 데이터가 없을 경우(TLB 미스), 스왑 영역으로 내려가 전체 테이블을 탐색합니다. 페이지 테이블 전체가 스왑 영역에 있으므로 사용할 수 있는 사용자 영역은 늘어나지만, 탐색 시간이 직접 매핑에 비해 매우 느려집니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`집합-연관 매핑`</span>은 스왑 영역에 저장된 페이지 테이블을 일정 구간의 집합으로 묶어서 관리하는 방식입니다. 현재 메모리에 올라와 있는 부분이 포함된 집합을 선택하여 데이터를 매우 빠른 속도 O(1)으로 찾을 수 있습니다. 하지만 집합 테이블을 추가적으로 생성해야 하는 단점이 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`역 매핑`</span>은 가상 주소의 분할 단위인 페이지가 아닌 **현재 적재 중인 물리 주소의 프레임**을 기준 인덱스로 테이블을 생성하는 기법입니다. 역 매핑의 페이지 테이블은 각 프레임을 할당하는 프로세스 아이디(PID)와 페이지 번호로 테이블이 구성되기 때문에 가상 공간에 속한 프로세스의 수와 상관없이 테이블의 크기가 일정하게 유지됩니다. 하지만 연관 매핑처럼 페이지 테이블 전체를 살펴봐야 하므로 데이터 검색에 취약합니다.

## 세그먼테이션-페이징 혼용 기법
세그먼테이션 기법은 물리 주소 공간을 **프로세스의 크기대로** 나누어 사용합니다. 메모리를 프로세스 단위로 관리하기 때문에 매핑 테이블이 작고 단순하다는 장점이 있지만, 심각한 외부 단편화 문제가 발생합니다.

세그먼테이션-페이징 혼용 기법은 코드, 데이터, 스택 영역으로 나뉘는 프로세스의 각 영역마다 주어진 권한(읽기, 쓰기, 실행)을 비트로 표시하는 권한 비트를 추가로 사용합니다. 권한 비트를 통해 해당 프로세스의 세그먼트 번호로 가서 자신의 영역을 벗어나는 페이지인지, 권한이 없는 페이지에 접근하는 것은 아닌지 확인합니다.

다시 말해 세그먼테이션-페이징 혼용 기법은 기존의 세그먼테이션 테이블에 권한 비트를 추가하여 우선적으로 메모리 오류(트랩)를 세그먼테이션 테이블에서 검사한 후, 집합-연관 매핑 방식으로 생성된 페이지 테이블을 통해 작업을 처리하는 방식입니다.

## 페이지 교체 알고리즘
필요한 프로세스 페이지가 메모리에 없는 상황을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`페이지 부재(Page Fault)`</span>라고 하며, 페이지 테이블을 활용해 매핑 후 스왑 영역에서 해당 페이지를 메모리로 가져와야 합니다. 이를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`요구 페이징`</span>이라고 합니다.

기존의 물리 메모리에 빈 프레임이 없을 때에는 메모리 내 프레임 중 하나를 스왑 영역으로 내보내야 하는데, 어떤 페이지를 스왑 영역으로 내보낼지 결정하는 알고리즘을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`페이지 교체 알고리즘`</span>이라고 합니다. 이때 알고리즘을 통해 교체 대상이 될 페이지를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`대상 페이지`</span>라고 합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`무작위 페이지 교체 알고리즘`</span>은 대상 페이지를 무작위로 선정합니다. 아무런 기준이 없으므로 알고리즘 성능이 좋지 않아 거의 사용하지 않습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`FIFO 페이지 교체 알고리즘`</span>은 시간상으로 가장 먼저 들어온 페이지가 가장 먼저 나가는 알고리즘입니다. 무작위 알고리즘보다는 합리적이지만 메모리에 먼저 들어왔어도 자주 사용되는 페이지가 있기도 하고, 나중에 들어왔어도 한 번만 사용되는 페이지가 있는 등의 여러 상황을 고려하지 않고 무조건 **선입선출(First IN First Out)** 방식으로 동작하기 떄문에 이 또한 성능이 좋은 편은 아닙니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`최적 페이지 교체 알고리즘`</span>은 미래에 사용될 페이지를 남겨두는 알고리즘입니다. 이론적으로는 완벽하지만 미래를 알 수 없기 때문에 실제 구현은 불가능합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`LRU 페이지 교체 알고리즘`</span>은 가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`LFU 페이지 교체 알고리즘`</span>은 가장 적게 사용한 페이지를 교체합니다. 

<span style="color: rgb(3, 150, 150); font-weight: bold;">`NUR 페이지 교체 알고리즘`</span>은 페이지 테이블의 플래그 비트 중 **참조, 변경 비트**를 사용한 방식입니다. 참조나 변경을 했을 경우 비트 값을 변경한 후 전체 페이지 중 계산된 비트 값이 가장 낮은 페이지를 대상 페이지로 선정합니다.

LRU, LFU, NUR 알고리즘을 묶어서 <span style="color: rgb(3, 150, 150); font-weight: bold;">`최적 근접 알고리즘`</span>이라 부릅니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`2차 기회 페이지 교체 알고리즘`</span>은 FIFO 알고리즘에서 먼저 진입하여 성공한 페이지를 곧바로 대상 페이지로 지정해 스왑 영역으로 보내는 것이 아니라, 다시 FIFO 페이지 큐의 맨 뒤로 넣는 방식입니다. 기존의 FIFO보다 자주 사용할 페이지를 좀 더 논리적으로 겨냥한 방식이라고 할 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`시계 알고리즘`</span>은 페이지를 가리키는 **포인터**와 **참조 비트**를 사용해 대상 페이지를 선정하는 알고리즘입니다. 포인터가 가리키는 페이지가 우선적으로 대상 페이지가 되며, 메모리에 페이지가 있다면 해당 페이지를 참조한 후 참조 비트를 1로 변경합니다.

만약 포인터가 가리키는 대상 페이지의 비트가 1이라면, 비트를 즉시 0으로 바꾸고 다음 페이지로 포인터를 건너뛰어 해당 페이지에 대한 기회를 한 번 더 제공합니다.

포인터가 최하단을 가리키게 되면 원형으로 돌려 다시 최상단으로 포인터를 변경 후 대상 페이지 선정을 계속 진행합니다.