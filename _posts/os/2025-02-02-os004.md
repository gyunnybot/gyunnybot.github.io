---
layout: single
title:  "메모리 관리"
folder: "os"
categories:
  - operatingsystem
permalink: categories/operatingsystem/os004
tags: OS
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 메모리 분할 방식 개요
물리적인 메모리(RAM)의 크기에 상관없이 프로세스가 실행될 수 있도록 공간을 지원하는 기술을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`가상 메모리`</span>라고 합니다. 물리 메모리와 하드 디스크의 스왑 영역을 합쳐서 가상 주소 공간을 할당하고, 실제 물리 메모리 주소와 일대일로 대응되는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`매핑 테이블`</span>을 생성하여 물리 메모리보다 크기가 큰 프로세스를 실행시키는 기술입니다.

CPU 스케줄러의 시분할 방식은 실제로 프로세스가 동시에 실행되는 것이 아니라, 프로세스의 실행 시간을 타임 슬라이스 방식으로 분할하여 빠른 문맥 교환을 통해 마치 동시에 실행되는 착각을 불러일으키는 방법입니다. 이와 마찬가지로 실행 중인 프로세스의 일부를 적절히 분할하여 메모리에 올려두고, 나머지는 스왑 영역에서 대기하여 스왑 인, 스왑 아웃 과정을 거쳐 전체 프로세스를 실행시키는 원리를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`메모리 오버레이`</span>라고 부릅니다.

물리 메모리를 분할하는 방식에는 고정 분할 기법을 사용한 <span style="color: rgb(3, 150, 150); font-weight: bold;">`페이징`</span> 기법과 프로세스 크기별로 분할하는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`세그먼테이션`</span> 기법이 있습니다. 각 기법은 장단점이 있으며, 오늘날에는 두 기법의 장점만을 가진 <span style="color: rgb(3, 150, 150); font-weight: bold;">`세그먼테이션-페이징 혼용`</span> 기법이 주로 사용되고 있습니다.

## 페이징 기법
페이징 기법은 물리 주소 공간을 같은 크기로 나누어 사용합니다. 가상 주소 공간과 물리 주소 공간의 분할된 페이지 크기가 같으며, 페이지 테이블에 의해 **일대일로 매핑**됩니다. 하나의 프로세스도 고정적으로 분할되어 처리되기 때문에 전체 메모리 입장에서는 메모리를 효율적으로 사용할 수 있지만, 내부 단편화 문제가 발생할 수 있으며 실행되는 프로세스에 의해 가상 주소 공간이 커짐에 따라 페이지 테이블의 크기도 비례하여 증가한다는 단점이 있습니다.

페이지 테이블은 일반적으로 메모리의 커널(운영체제) 영역에 저장되는 데이터베이스입니다. 따라서 테이블의 크기가 너무 커져버리게 되면 실제 사용자 프로세스가 사용할 수 있는 메모리 영역이 줄어들게 됩니다. 이처럼 사용할 수 있는 영역이 줄어들 경우, 페이지 테이블 또한 스왑 영역으로 옮겨서 관리할 수 있습니다. 페이지 테이블의 위치와 매핑 방식에 따라 직접 매핑, 연관 매핑, 집합-연관 매핑, 역 매핑으로 나눌 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`직접 매핑`</span>은 물리 메모리 내 운영체제 영역에 페이지 테이블이 저장된 방식입니다. 테이블에 직접 접근하므로 O(1)의 속도로 데이터를 찾을 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`연관 매핑`</span>은 페이지 테이블이 전부 스왑 영역에 저장된 방식으로, 일부 테이블의 레코드를 **무작위**로 뽑아 **변환 색인 버퍼(TLB)**를 형성한 후 매핑을 진행합니다. 변환 색인 버퍼는 초기의 페이지 테이블처럼 순서가 연결된 자료구조가 아니므로 데이터 탐색에 O(N)의 속도가 걸립니다. 심지어 테이블에 원하는 데이터가 없을 경우(TLB 미스), 스왑 영역으로 내려가 전체를 탐색합니다. 페이지 테이블 전체가 스왑 영역에 있으므로 사용할 수 있는 물리 메모리 영역은 늘어나지만, 탐색 시간이 직접 매핑에 비해 느립니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`집합-연관 매핑`</span>은 스왑 영역에 저장된 페이지 테이블을 일정 구간의 집합으로 묶어서 관리하는 방식입니다. 현재 메모리에 올라와 있는 부분 집합을 선택해 데이터를 매우 빠른 속도 O(1)으로 찾을 수 있습니다. 하지만 집합 테이블을 메모리에 따로 생성해야 하는 단점이 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`역 매핑`</span>은 가상 주소의 분할 단위인 페이지가 아닌 물리 주소의 프레임을 기준으로 테이블을 생성하는 기법입니다. 각 프레임을 할당하는 프로세스의 아이디와 페이지 번호로 테이블이 구성되기 때문에 프로세스의 수와 상관없이 테이블의 크기가 일정하게 유지됩니다. 하지만 연관 매핑처럼 페이지 테이블 전체를 살펴봐야 하므로 데이터 검색에 취약합니다.

## 세그먼테이션-페이징 혼용 기법
세그먼테이션 기법은 물리 주소 공간을 프로세스의 크기로 나누어 사용합니다. 메모리를 프로세스 단위로 관리하기 때문에 매핑 테이블이 작고 단순하다는 장점이 있지만, 외부 단편화 문제가 발생합니다.

세그먼테이션-페이징 혼용 기법은 코드, 데이터, 스택 영역으로 나뉘는 프로세스의 각 영역에 주어진 권한을 비트로 표시하는 권한 비트를 사용합니다. 기존의 세그먼테이션 테이블에 권한 비트를 추가하여 우선적으로 메모리 오류(트랩)를 세그먼테이션 테이블에서 검사한 후, 연관 매핑 방식으로 페이지 테이블을 스왑 영역에서 처리하는 방식입니다.

## 페이지 교체 알고리즘 정리
필요한 프로세스 페이지가 메모리에 없는 상황을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`페이지 부재`</span>라고 하며, 페이지 테이블로 매핑 후 스왑 영역에서 해당 페이지를 메모리로 가져와야 합니다. 이를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`요구 페이징`</span>이라고 합니다.

기존의 물리 메모리에 빈 프레임이 없을 때에는 메모리 내 프레임 중 하나를 스왑 영역으로 내보내야 하는데, 어떤 페이지를 스왑 영역으로 내보낼지 결정하는 알고리즘을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`페이지 교체 알고리즘`</span>이라고 합니다. 교체 대상이 될 페이지를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`대상 페이지`</span>라고 합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`무작위 페이지 교체 알고리즘`</span>은 대상 페이지를 무작위로 선정합니다. 아무런 기준이 없으므로 알고리즘 성능이 좋지 않아 거의 사용하지 않습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`FIFO 페이지 교체 알고리즘`</span>은 시간상으로 가장 먼저 들어온 페이지가 가장 먼저 나가는 알고리즘입니다. 무작위 알고리즘보다는 합리적이지만 메모리에 먼저 들어왔어도 자주 사용되는 페이지가 있기도 하고, 나중에 들어왔어도 한 번만 사용되는 페이지가 있는 등의 여러 상황을 고려하지 않고 무조건 **선입선출 방식**으로 동작하기 떄문에 이 역시 성능이 좋은 편은 아닙니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`최적 페이지 교체 알고리즘`</span>은 미래에 사용될 페이지를 남겨두는 알고리즘입니다. 이론적으로는 완벽하지만 실제로 구현이 불가능합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`LRU 페이지 교체 알고리즘`</span>은 가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`LFU 페이지 교체 알고리즘`</span>은 가장 적게 사용한 페이지를 교체합니다. 

<span style="color: rgb(3, 150, 150); font-weight: bold;">`NUR 페이지 교체 알고리즘`</span>은 페이지 테이블의 플래그 비트 중 **참조, 변경 비트**를 사용한 방식입니다. 참조나 변경을 했을 경우 각 비트를 1로 만들고 전체 페이지 중 두 비트의 숫자가 가장 낮은 페이지를 대상 페이지로 선정합니다.

LRU, LFU, NUR 알고리즘을 묶어서 <span style="color: rgb(3, 150, 150); font-weight: bold;">`최적 근접 알고리즘`</span>이라 부릅니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`2차 기회 페이지 교체 알고리즘`</span>은 FIFO 알고리즘에서 성공한 페이지를 대상 페이지로 지정해 곧바로 스왑 영역으로 보내는 것이 아니라, 다시 FIFO 페이지 큐의 맨 뒤로 넣는 방식입니다. 기존의 FIFO보다 자주 사용할 페이지를 좀 더 논리적으로 겨냥한 방식이라고 할 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`시계 알고리즘`</span>은 페이지를 가리키는 **포인터**와 **참조 비트**를 사용해 대상 페이지를 선정하는 알고리즘입니다. 메모리 상단부터 생성되는 포인터가 가리키는 페이지가 우선적으로 대상 페이지가 되며, 메모리에 페이지가 있을 시 참조 비트를 1로 변경합니다.

포인터가 가리키는 페이지(대상 페이지)의 비트가 1일 때에는 다음 페이지로 건너뛰며, 페이지의 비트를 0으로 바꿔 해당 페이지에 대한 기회를 한 번 더 제공합니다. 시계 알고리즘은 포인터를 원형으로 돌리면서 대상 페이지 선정을 진행합니다.