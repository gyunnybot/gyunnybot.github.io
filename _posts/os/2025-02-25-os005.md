---
layout: single
title:  "멀티스레드 모델"
folder: "os"
categories:
  - operatingsystem
permalink: categories/operatingsystem/os005
tags: OS
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 멀티스레드 모델
프로세스는 커널 프로세스(스레드)와 사용자 프로세스로 나뉘며, 스레드 또한 커널 스레드와 사용자 스레드로 나뉩니다.

사용자 스레드는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`시스템 호출(System Call)`</span>을 통해 커널의 기능을 사용할 수 있는데, 사용자 스레드에 대한 커널 스레드의 대응 방식에 따라 3가지 모델로 분류할 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`사용자 스레드 모델(1 to N 모델)`</span>은 프로세스를 구성하는 여러 사용자 스레드가 단 하나의 커널 스레드와 연결된 형태입니다.

\'CPU의 작업 단위는 스레드\'라는 문장에서 스레드는 컴퓨터 사양을 고려할 때 적용되는 하드웨어 스레드(이하 논리 프로세서)가 아닌 운영체제에서 통용되는 소프트웨어 스레드를 말합니다. 그런데 프로세스가 실행되면서 수행되는 소프트웨어 스레드 중 실제로 논리 프로세서가 실행하는 스레드는 **커널 스레드**뿐입니다. 사용자 스레드가 자원 활용이나 입출력 같은 커널의 기능을 사용하려면 시스템 호출을 통해 커널 모드로 전환해야 하는데, 이 과정에서 결국 커널 스레드가 실행되기 때문입니다.

다시 말해 사용자 스레드는 커널 스레드에 의해 간접적으로 실행되는 스레드일 뿐, 시스템 호출 등의 커널 관련 작업이 발생한다고 해서 사용자 스레드 자체가 커널 스레드로 변할 수는 없습니다.

사용자 스레드 모델은 사용자 영역에서 스레드를 직접 구현하며 스레드 라이브러리를 통해 스케줄링 및 동기화 기능을 커널 없이 자체적으로 처리합니다. 즉, 사용자 스레드 모델에서의 프로세스 내 스레드는 커널 모드로 전환될 필요가 없어져 커널 스레드 기반의 문맥 교환이 발생하지 않아 이후 설명할 다른 모델들에 비해 프로세스가 빠르게 실행된다는 장점이 있습니다.

그러나 사용자 스레드 모델은 여러 사용자 스레드가 하나의 커널 스레드로만 연결되어 있기 때문에 스레드가 여러 개 존재하더라도 커널 입장에서는 하나의 커널 스레드로만 보입니다. 따라서 멀티코어 환경이 마련되어도 CPU 내 논리 프로세서가 하나의 커널 스레드로만 인식하기 때문에 프로세스 내 생성된 소프트웨어 스레드의 병렬처리가 어렵다는 단점이 있습니다.

또한, 하나의 스레드가 블로킹 시스템 호출을 수행하면 같은 프로세스 내의 다른 스레드도 함께 블로킹되어 성능 저하가 발생할 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`커널 스레드 모델(1 to 1 모델)`</span>은 커널이 멀티스레드를 지원하는 방식으로 사용자 스레드와 커널 스레드가 1:1로 연결되어 작업이 수행됩니다. 이는 사실상 각각의 사용자 스레드가 커널 스레드에게 작업을 위임하는 방식이라고 할 수 있습니다.

멀티코어 환경에서 멀티프로세싱 방식을 적용해 CPU 전체를 효율적으로 사용할 수 있으나, 논리 프로세서보다 커널 스레드가 많아질 경우 잦은 문맥 교환 오버헤드가 발생해 사용자 스레드 모델보다 느리게 작동할 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`멀티레벨 스레드 모델(M to N 모델)`</span>은 사용자 스레드 모델과 커널 스레드 모델을 혼합한 방식으로 멀티레벨 스레드 모델에서는 커널 스레드의 개수가 사용자 스레드보다 작거나 같습니다.