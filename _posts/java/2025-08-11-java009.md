---
layout: single
title:  "문자열 상수 풀과 참조"
folder: "java"
categories:
  - java
permalink: categories/java/java009
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 문자열 리터럴과 상수 풀
Java에서 문자열을 다루다 보면 `==` 비교가 될 때도 있고, 안 될 때도 있다. 이 차이를 이해하기 위해선 String Constant Pool(상수 풀)과 힙 영역의 관계를 먼저 알아야 한다.

Java에서 문자열 리터럴(예: "Hello")은 메서드 영역 내 String Constant Pool에 저장된다. 동일한 리터럴이 코드에 여러 번 등장하더라도, 상수 풀에는 단 하나의 정적인 문자열 객체로 존재한다.

```
String a = "Hello"; //이때 0x01에 "Hello" 저장
String b = "Hello"; //0x01의 값을 그대로 참조

상수 풀: 0x01 → "Hello" //상수 풀에서 오로지 하나만 생성

a → 0x01
b → 0x01

a == b: true
a.equals(b): true
```

<br>
"Hello"는 상수 풀에 한 번만 올라가고, a와 b는 같은 객체(같은 참조값)를 공유한다. 그래서 `==` 연산의 결과는 true가 나온다.

## new String()이 만든 객체일 때
한편, new String("Hello")는 상수 풀에 있는 "Hello"를 복사하여 힙 영역에 새로운 String 객체를 만든다.

```
String a = new String("Hello"); //이때 0x01에 "Hello" 저장. 그러나 a는 0x02를 가리킨다
String b = "Hello"; //0x01의 값을 그대로 참조

상수 풀: 0x01 → "Hello"
힙: 0x02 → "Hello"

a → 0x02
b → 0x01

a == b: false
a.equals(b): true
```

<br>
여기서 중요한 점은 new String()을 쓰면 무조건 새 힙 객체가 생긴다는 것이다. new String("hello")를 여러 번 호출하면 매번 힙에 새로운 객체가 생긴다.

```
String a = new String("hello"); //이때 0x01에 "Hello" 저장. 그러나 a는 0x02를 가리킨다
String b = new String("hello"); //b는 0x03을 가리킨다

상수 풀: 0x01 → "hello"
힙: 0x02 → "hello", 0x03 → "hello"

a → 0x02
b → 0x03

a == b: false
a.equals(b): true
```

## 상수 풀을 참고한다는 것은...
새로운 힙 객체를 만들 때 \'상수 풀을 참고한다\'는 건, 인스턴스 생성 시 상수 풀의 값을 기반으로 한다는 뜻이다. new String("hello") 실행 시 JVM은 먼저 상수 풀에서 "hello" 객체를 찾고, 그 내용을 복사해 힙 객체를 만든다. 즉, 힙 객체를 만드는 데 상수 풀의 값이 재료처럼 사용되는 것이다.

## new String()만 있어도 상수 풀은 생성된다
중요한 사실이 있는데, 리터럴 생성 없이 String s1 = new String("hello");가 프로그램에서 처음 등장하는 경우에도 "hello"가 상수 풀에 올라간 이후에 힙 영역에서 객체가 생성된다. 다시 말해 리터럴 "hello"가 코드에 존재하는 그 순간, 컴파일 타임에 상수 풀 항목이 자동으로 생성된다는 것이다.

정리하면 상수 풀은 문자열 리터럴의 저장소이고, 힙은 객체의 저장소다. new String()은 상수 풀 값을 가져다 복사해서 새 주소를 만든다. 리터럴은 주소를 공유하고, new는 새 주소를 만든다.