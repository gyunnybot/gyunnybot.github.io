---
layout: single
title:  "문자열 상수 풀과 참조"
folder: "java"
categories:
  - java
permalink: categories/java/java009
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 문자열 리터럴과 상수 풀
자바에서 문자열을 다루다 보면 `==` 비교가 될 때도 있고, 안 될 때도 있다. 이 차이를 이해하기 위해선 문자열 상수 풀(String Constant Pool)과 힙 영역의 관계를 먼저 알아야 한다.

문자열 리터럴(예: "Hello")은 메서드 영역 내 문자열 상수 풀에 저장된다. 동일한 리터럴이 코드에 여러 번 등장하더라도, 상수 풀에 단 하나의 정적인 문자열 객체로 존재한다. 아래 예시에서 0x01 따위의 주소 표현은 실제가 아니라, \'자바 메모리 구조 내 데이터가 저장되었다\'라고 이해해야 한다.

```
String a = "Hello"; //이때 0x01에 "Hello" 저장
String b = "Hello"; //0x01의 값을 그대로 참조

상수 풀: 0x01 → "Hello" //상수 풀에서 오로지 하나만 생성

a → 0x01
b → 0x01

a == b: true
a.equals(b): true
```

<br>
"Hello"는 상수 풀에 한 번만 생성되고, a와 b는 같은 객체(같은 참조값)를 공유한다. 그래서 `==` 연산의 결과는 true로 출력된다.

## new String()이 만든 객체일 때
한편, new String("Hello")는 상수 풀에 있는 "Hello"를 복사하여 힙 영역에 새로운 String 객체를 만든다.

```
String a = new String("Hello"); //이때 0x01에 "Hello" 저장. 그러나 a는 0x02를 가리킨다
String b = "Hello"; //0x01의 값을 그대로 참조

상수 풀: 0x01 → "Hello"
힙: 0x02 → "Hello"

a → 0x02
b → 0x01

a == b: false
a.equals(b): true
```

<br>
중요한 점은 new String()을 쓰면 상수 풀과는 달리 무조건 새로운 힙 객체가 생긴다는 것이다. new String("hello")를 여러 번 호출하면 매번 힙에 새로운 객체가 생긴다.

```
String a = new String("hello"); //이때 0x01에 "Hello" 저장. 그러나 a는 0x02를 가리킨다
String b = new String("hello"); //b는 0x03을 가리킨다

상수 풀: 0x01 → "hello"
힙: 0x02 → "hello", 0x03 → "hello"

a → 0x02
b → 0x03

a == b: false
a.equals(b): true
```

## new String()만 있어도 상수 풀은 생성된다
새로운 힙 객체를 만들 때 \'상수 풀을 참고한다\'는 말은 인스턴스 생성 시 상수 풀의 값을 기반으로 한다는 뜻이다. new String("hello") 실행 시 JVM은 먼저 상수 풀에서 "hello" 객체를 찾고, 그 내용을 복사해 힙 객체를 만든다. 즉, 힙 객체를 만드는 데 상수 풀의 값이 재료처럼 사용되는 것이다.

한편, 기존에 생성된 문자열 리터럴 없이 String s1 = new String("hello");가 프로그램에서 처음 등장하는 경우라면, "hello"가 상수 풀에 생성된 이후에 힙 영역에서 객체가 생성된다. 다시 말해 리터럴 "hello"가 코드에 존재하는 그 순간, 컴파일 타임에 상수 풀 항목이 자동으로 생성된다.

정리하면 상수 풀은 문자열 리터럴의 저장소이고, 힙은 객체의 저장소다. new String()은 상수 풀 값을 가져다 복사해서 새 주소를 만든다. 없다면 상수 풀에 생성 후 사용한다. 리터럴은 주소를 공유하고, new 연산은 새 주소를 만든다.