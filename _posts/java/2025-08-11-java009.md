---
layout: single
title:  "문자열 상수 풀과 참조"
folder: "java"
categories:
  - java
permalink: categories/java/java009
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 문자열 리터럴과 상수 풀
자바에서 문자열을 다루다 보면 `==` 비교가 될 때도 있고, 안 될 때도 있다. 이 차이를 이해하기 위해선 동일성과 동등성의 차이를 알아야 하며, 그 전에 문자열 상수 풀(String Constant Pool)과 힙 영역 사이의 관계를 먼저 알아야 한다.

문자열 리터럴(예: "Hello")은 자바(프로세스)의 메모리 구조에서 메서드 영역 내 문자열 상수 풀에 저장된다. 동일한 리터럴이 코드에 여러 번 등장하더라도 상수 풀에 단 하나의 정적인 문자열로 존재한다.

아래에서 0x01과 같은 주소 표현은 실제가 아니라 예시일 뿐이며, \'자바 메모리 내 특정 부분에 데이터가 저장되었다\'라고 이해하면 된다.

```
String a = "Hello"; //이때 0x01(메서드 영역)에 "Hello" 저장. 0x01의 값을 그대로 참조
String b = "Hello"; //0x01의 값을 그대로 참조

상수 풀: 0x01 → "Hello" //상수 풀에 오로지 하나만 생성된다

a → 0x01
b → 0x01

a == b: true
a.equals(b): true
```

<br>
"Hello"는 상수 풀에 한 번만 생성되고, a와 b는 같은 객체(같은 참조값)를 공유한다. 그래서 `==` 연산의 결과는 true로 출력된다.

## new String()이 만든 객체일 때
한편, new String("Hello")는 상수 풀에 있는 "Hello"를 \'복사\'하여 힙 영역에 새로운 String 객체를 만든다.

```
String a = new String("Hello"); //이때 0x01(메서드 영역)에 "Hello" 저장. 그러나 a는 0x02 참조
String b = "Hello"; //0x01의 값을 그대로 참조

상수 풀: 0x01 → "Hello"
힙: 0x02 → "Hello"

a → 0x02
b → 0x01

a == b: false
a.equals(b): true
```

<br>
중요한 점은 new String()을 쓰면 상수 풀과는 달리 무조건 새로운 힙 객체가 생긴다는 것이다. 따라서 new String("Hello")를 여러 번 호출하면 매번 힙에 새로운 객체가 생긴다.

```
String a = new String("Hello"); //이때 0x01(메서드 영역)에 "Hello" 저장. 그러나 a는 0x02 참조
String b = new String("Hello"); //b는 0x03 참조

상수 풀: 0x01 → "Hello"
힙: 0x02 → "Hello", 0x03 → "Hello"

a → 0x02
b → 0x03

a == b: false
a.equals(b): true
```

## new String()만 있어도 상수 풀은 생성된다
새로운 힙 객체를 만들 때 \'상수 풀을 참고한다\'는 말은 인스턴스 생성 시 상수 풀의 리터럴을 복사한다는 뜻이다. new String("Hello") 실행 시 JVM은 먼저 상수 풀에서 "Hello" 객체를 찾고, 그 내용을 복사해 힙 객체를 만든다. 즉, 힙 객체를 만드는 데 상수 풀의 값이 재료처럼 사용되는 것이다.

한편, 기존에 생성된 문자열 리터럴 없이 String s1 = new String("Hello");가 프로그램에서 처음 등장하는 경우에도 "Hello"가 상수 풀에 생성된 이후에 힙 영역에서 객체가 생성된다. 다시 말해 리터럴이든 힙 객체든 "Hello"가 코드 영역에 존재하는 그 순간, 컴파일 타임에 상수 풀에 리터럴이 자동으로 생성된 후 절차가 진행된다.

정리하면 상수 풀은 문자열 리터럴의 저장소이고, 힙은 객체의 저장소다. new String()은 상수 풀 내 리터럴을 가져다 복사해서 새 주소를 만든다. 리터럴이 없다면 상수 풀에 우선 생성한 후, 그 값을 복사하여 사용한다. 리터럴은 주소를 공유하고, new 연산은 새 주소를 만든다.

## 동일성과 동등성
`==` 연산은 비교할 대상 a와 b가 정말로 같은 메모리 내 특정 부분을 차지하는지(참조) 물어보는 셈이다. 예를 들어 단순히 리터럴을 동등 연산으로 받았다면, 메서드 영역 내 문자열 상수 풀 어딘가의 참조를 공유하는 것이므로 true를 반환한다. 이것이 동일성이다.

반면 new로 생성된 객체는 다르다. 상수 풀 내 리터럴의 값을 복사해 힙 영역에서 새로운 메모리를 할당 후 저장하는 방식이기 때문에 `==` 연산은 반드시 false를 반환한다. 그러나 똑같은 \'값\'을 상수 풀로부터 받았기 때문에 논리적으로 a와 b는 같은 문자열이다. 따라서 String 타입에서 a.equals(b)는 true를 반환하는데, 이것이 동등성이다. 동등성은 참조의 같음이 아닌, 값의 같음을 확인한다.