---
layout: single
title:  "리플렉션과 애노테이션"
folder: "java"
categories:
  - java
permalink: categories/java/java008
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 리플렉션
클래스 이름, 메서드, 필드, 생성자 등의 정보를 런타임에 동적으로 가져와 사용할 수 있는 기능을 <span style="color: rgb(3, 150, 150); font-weight: bold;">`리플렉션(Reflection)`</span>이라 합니다. 기존에는 클래스의 기능을 사용하려면 객체를 생성하고 반드시 이를 통해 접근해야 했지만, 리플렉션을 활용하면 클래스 메타데이터를 통해 클래스 내 모든 정보에 **동적으로** 접근이 가능합니다.

```java
package reflection.prac;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class PersonMain {
    public static void main(String[] args) throws Exception {
        Person person = new Person();
        person.sayHello(); //정적인 메서드 접근. Hello, I'm Alice

        //클래스 메타데이터 조회 방법 3가지
        Class<? extends Person> aClass = person.getClass(); //1. 인스턴스에서 찾기
        //Class<Person> aClass = Person.class; //2. 클래스에서 찾기
        //Class<?> aClass = Class.forName("reflection.prac.PersonMain$Person"); //3. 문자로 찾기

        Field nameField = aClass.getDeclaredField("name"); //name 필드 찾기
        nameField.setAccessible(true); //private 필드 접근 허용
        nameField.set(person, "Bob");

        Method aClassDeclaredMethod = aClass.getDeclaredMethod("sayHello"); //동적 메서드 접근
        aClassDeclaredMethod.invoke(person); //Hello, I'm Bob
    }

    public static class Person { //정적 중첩 클래스는 $로 경로를 선언할 수 있다
        private String name = "Alice";

        public void sayHello() {
            System.out.println("Hello, I'm " + this.name);
        }
    }
}
```

리플렉션을 활용하면 `private` 접근 제어자에도 직접 접근해서 값을 변경할 수 있습니다. 하지만 이는 객체 지향 프로그래밍의 원칙을 위반하는 행위로, 캡슐화 및 유지보수성에 악영향을 미칠 수 있습니다.

따라서 리플렉션을 사용할 때는 반드시 신중하게 접근해야 하며, 가능한 경우 접근 메서드(예: getter, setter)를 사용하는 것이 바람직합니다.

## 애노테이션
<span style="color: rgb(3, 150, 150); font-weight: bold;">`애노테이션(Annotation)`</span>은 코드에 **메타데이터(Metadata)**를 추가하는 문법입니다. 주석처럼 보이지만, 컴파일러나 런타임에서 특정 동작을 유도하는 역할을 합니다.

\`@Override\`, \`@Deprecated\`, \`@SuppressWarnings\`처럼 JAVA가 기본적으로 제공하는 애노테이션을 사용할 수도 있지만, 직접 애노테이션을 생성하는 것도 가능합니다.