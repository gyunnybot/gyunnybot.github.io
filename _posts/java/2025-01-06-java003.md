---
layout: single
title:  "예외 처리"
folder: "java"
categories:
  - java
permalink: categories/java/java003
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 예외 처리
JAVA 예외는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`체크(check)`</span>와 <span style="color: rgb(3, 150, 150); font-weight: bold;">`언체크(uncheck, 런타임)`</span> 예외로 나뉩니다. 체크 예외는 프로그램 내에서 반드시 처리를 해야 하며, 그렇지 않으면 컴파일 오류가 발생합니다. 반면 언체크 예외는 처리 의무가 없습니다.

예외 또한 객체이며 Exception을 상속받은 클래스로 생성할 수 있습니다. 생성된 예외는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`throw`</span>를 통해 발생시킬 수 있습니다.

해당 클래스에서 오류가 발생했다면 <span style="color: rgb(3, 150, 150); font-weight: bold;">`try-catch-finally`</span>를 활용해 오류를 잡거나, <span style="color: rgb(3, 150, 150); font-weight: bold;">`throws`</span>를 통해 상위 메서드로 넘겨 해결해야 합니다.

try 블록은 예외가 발생할 수 있는 로직을 포함합니다. 이후 catch에서 예외를 겨냥 후 처리합니다. catch 블록은 절차적으로 진행되기 때문에 **세부적인 예외 처리를 우선적으로 작성**해야 합니다. finally 블록은 예외 해결 여부와 관계없이 무조건 실행됩니다.

모든 오류를 전부 알고 대응하는 것은 불가능한 일입니다. 따라서 특별하게 처리해야 하는 세부적인 예외는 catch를 활용해 우선적으로 잡고, 나머지는 모든 예외의 부모 클래스인 Exception으로 묶어서 해결하는 편이 합리적입니다.

```java
try{
	client.connect(); //연결 예외 발생 가능성이 있는 메서드 호출
	client.send(data); //전송 예외 발생 가능성이 있는 메서드 호출
}
catch (ConnectException e){ //연결 예외 우선적으로 처리
	System.out.println("[연결 오류] 주소: " + e.getAddress() +
	", 메세지: " + e.getMessage());
}

//네트워크 예외는 연결, 전송 두가지 예외만 있다고 가정
//데이터는 네트워크 연결 이후에 전송할 수 있으므로 전송 예외는 연결 예외 이후에 처리
catch (NetworkClientException e) { //전송 예외 처리
	System.out.println("[네트워크 오류] 메세지: " + e.getMessage());
}
catch (Exception e){ //그 외 예외는 최상위 예외 Exception으로 잡아 한번에 처리
	System.out.println("[알 수 없는 오류] 메세지: " + e.getMessage());
}
finally { //예외 해결 여부에 관계없이 반드시 실행되는 구문
	client.disconnect();
}
```

## try-with-resource
외부 자원을 사용한 후에는 반드시 연결을 해제해야 하며, 반드시 실행되는 finally 블록을 사용해 자원을 반환하는 방법을 떠올릴 수 있습니다. 하지만 JAVA는 문법적으로 finally를 놓치더라도 컴파일 오류가 발생하지 않기 때문에 연결 해제가 누락될 수 있는 문제가 있습니다.

JAVA 7부터 try 블록 내에 외부 자원임을 알리고 try가 끝나는 시점에 자동으로 연결을 해제하는 try-with-resource 기능이 도입되었습니다. try 블록에서 사용되는 클래스는 반드시 AutoCloseable 인터페이스를 구현해야 하며, 블록이 끝나면 자동으로 <span style="color: rgb(3, 150, 150); font-weight: bold;">`AutoCloseable.close()`</span>를 호출하여 외부 자원을 반환합니다.

```java
//try-catch-finally. try 블록 외부에 인스턴스를 생성합니다
NetworkClientV1 client = new NetworkClientV1(address);

client.initError(data);

try {
	client.connect();
	client.send(data);
}
catch (ConnectException e){
	System.out.println("[연결 오류] 주소: " + e.getAddress() +
	", 메세지: " + e.getMessage());
}
catch (NetworkClientException e) {
	System.out.println("[네트워크 오류] 메세지: " + e.getMessage());
}
catch (Exception e){
	System.out.println("[알 수 없는 오류] 메세지: " + e.getMessage());
}
finally {
	client.disconnect();
}
```

```java
//try-with-resource. try 블록 내에서 인스턴스를 생성합니다
try (NetworkClientV2 client = new NetworkClientV2(address)) {
	client.initError(data);
	client.connect();
	client.send(data);
    //client.close(); //AutoCloseable.close()를 자동으로 호출해 자원 반환
}
catch (Exception e) {
	System.out.println("[예외 확인]: " + e.getMessage());
	throw e;
}
```