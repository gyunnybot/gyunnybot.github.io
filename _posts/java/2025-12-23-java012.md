---
layout: single
title:  "default 구분하기"
folder: "java"
categories:
  - java
permalink: categories/java/12
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## default 접근제어자
Java를 공부하다 보면 \'default\'라는 단어가 두 군데에서 전혀 다른 의미로 등장해 헷갈리기 쉽다(내 이야기). 하나는 접근 제어자 문맥에서의 default이고, 다른 하나는 인터페이스 메서드 문맥에서의 default다.

먼저 `class A {}`와 같이 클래스(또는 메서드/필드)에 public/protected/private를 붙이지 않으면, 이것을 흔히 \'default 접근\'이라고 부른다. 정확한 의미는 package-private으로 같은 패키지 안에서만 접근 가능하다는 뜻이 된다. 여기서의 default는 실제 키워드가 아니라 \'아무 것도 쓰지 않은 상태(생략)\'를 가리키는 접근제어자의 의미로 사용되는 관용적인 표현이다.

## default 키워드
반면에 인터페이스에서의 default는 아예 다른 이야기다. Java 8부터 인터페이스는 구현을 가진 메서드를 가질 수 있게 되었고, 이때 default 키워드가 사용되었다. `default void turnOff() { ... }`처럼 \'이 메서드는 추상(abstract)이 아니라 기본 구현을 제공한다\'는 의미를 명확히 표시한다.

인터페이스 내에 정의된 메서드는 기본이 public abstract이다. 그런데 abstract 대신 default를 사용해 메서드를 정의하게 되면 public만이 남게 된다. 그래서 구현 클래스(자식)에서 이 메서드를 재정의할 때는 default를 쓰는 게 아니라 일반 메서드처럼 `public void turnOff() { ... }` 방식으로 재정의해야 한다.

    이 메서드는 추상화(abstract)되어 있으므로 반드시 재정의가 필요한 것인데, 추상화를 빼고 디폴트(default)로
    구현된 로직을 사용해도 좋습니다. 재정의하지 않으면 기본 구현(public)된 로직을 사용합니다.

정리하면, 접근 제어자의 default는 생략 상태(package-private), 인터페이스의 default는 \'직접 써야 하는 키워드(기본 구현)\'로 기억하면 깔끔하게 정리할 수 있다.

## 디폴트 메서드가 나온 이유
자바는 초창기부터 인터페이스(명세)와 구현(클래스)를 깔끔하게 분리해 온 언어다. 그래서 오랫동안 인터페이스는 \'메서드 시그니처만 선언하는 계약(Contract)\' 역할에 충실했고, 구현 코드는 오직 클래스가 책임졌다. 이 덕분에 다형성과 설계 유연성이 커졌지만, 동시에 하나의 강한 제약이 생겼다. 인터페이스에 메서드를 추가하는 순간, 그 인터페이스를 구현한 모든 클래스가 컴파일 오류를 내며 수정 대상이 된다는 점이다.

문제는 이 제약이 표준 라이브러리 수준에서 더 치명적이라는 데 있다. Collection, List처럼 널리 쓰이는 인터페이스는 수많은 구현체와 서드파티 라이브러리 위에 얹혀 있다. 만약 자바가 버전 업과 함께 이런 인터페이스에 새 메서드를 추가한다면, 전 세계 코드베이스가 한꺼번에 깨질 것이다. 자바가 하위 호환성을 강하게 중시하는 이유가 여기에 있고, 실제로 이 때문에 인터페이스 확장이 쉽지 않았다. 결국 \'인터페이스를 진화시키되 기존 코드는 깨지지 않게\' 만드는 장치가 필요했다.

그래서 자바 8에서 등장한 것이 디폴트 메서드(default method)다. 디폴트 메서드는 인터페이스에 default 키워드로 구현을 가진 메서드를 추가할 수 있게 해준다. 덕분에 새로운 메서드를 인터페이스에 더하더라도, 기존 구현 클래스들은 그 메서드를 당장 재정의하지 않아도 기본 구현을 사용하며 정상 동작한다. 표준 라이브러리가 List.sort(...), Iterable.forEach(...), Collection.stream()처럼 람다와 스트림 API와 자연스럽게 맞물리는 기능들을 확장할 수 있었던 것도 이 변화 덕분이다.

다만 디폴트 메서드는 \'인터페이스가 곧 구현을 품는다\'는 의미이기도 해서, 설계 측면에서 사용법이 중요하다. 디폴트 메서드는 원래 목적이 하위 호환성 확보인 만큼, 가능하면 최소한의 범위에서만 쓰는 게 좋다. 또한 인터페이스는 여전히 계약의 역할이 중심이어야 하므로, 복잡한 비즈니스 로직을 디폴트 메서드로 몰아넣으면 추상화 경계가 흐려지고 유지보수가 어려워질 수 있다. 공통으로 쓰기 쉬운 짧은 기본 동작을 제공하거나, 기존 인터페이스를 안전하게 확장해야 할 때 신중하게 선택하는 편이 낫다.

또 하나 기억할 점은 충돌 해결이다. 한 클래스가 여러 인터페이스를 구현할 때, 서로 다른 인터페이스가 같은 시그니처의 디폴트 메서드를 제공하면 어떤 구현을 쓸지 모호해진다. 이 경우 구현 클래스에서 반드시 오버라이드로 충돌을 해결해야 하며, 필요하다면 `A.super.method()`처럼 특정 인터페이스의 기본 구현을 명시적으로 호출할 수도 있다. 결론적으로 디폴트 메서드는 자바가 하위 호환성을 지키면서도 인터페이스를 진화시키기 위해 택한 현실적인 해법이고, 편리함보다 \'설계 의도\'를 먼저 떠올릴 때 가장 빛을 발한다.