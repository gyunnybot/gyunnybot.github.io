---
layout: single
title:  "Executor 프레임워크"
folder: "java"
categories:
  - java
permalink: categories/java/java006
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## Executor 프레임워크
스레드를 직접 생성하는 경우, 스레드를 생성, 관리하는 단계부터 커널과 CPU 자원을 소모하게 됩니다. 또 Runnable 인터페이스는 반환값이 없으므로 스레드를 통해 값을 도출하려면 변수를 생성 후 따로 저장해 출력해야하는 번거로움 또한 존재합니다. JAVA는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`스레드 풀(Thread Pool)`</span> 기능을 가지고 있는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`Executor`</span> 인터페이스 프레임워크를 지원합니다. 스레드 풀에 미리 생성된 스레드를 통해 수행해야 하는 작업을 처리 후 다시 풀에 반납하는 방식을 제공하므로써 사용자가 직접 스레드를 생성, 관리해야하는 불편함을 덜어주는 기술입니다.

일반적으로 Executor 인터페이스를 구현한 <span style="color: rgb(3, 150, 150); font-weight: bold;">`ExecutorService`</span> 인터페이스를 멀티스레드 상황에서 채택하고, ExecutorService의 기본 구현체인 <span style="color: rgb(3, 150, 150); font-weight: bold;">`ThreadPoolExecutor`</span>를 통해 스레드 풀을 구현합니다.

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                            TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

## Callable, Future
Runnable을 통해 스레드를 직접 생성하는 경우 Thread.join()을 통해 각 스레드의 결과를 대기 후 전달받아 작업을 처리했다면, Executor 인터페이스 환경에서는 Runnable 대신 <span style="color: rgb(3, 150, 150); font-weight: bold;">`Callable`</span>, Thread.join()을 대신해 <span style="color: rgb(3, 150, 150); font-weight: bold;">`Future.get()`</span>을 통해 동일한 프로세스를 수행할 수 있습니다. Callable은 Runnable과 달리 반환값을 가질 수 있고 예외를 던질 수 있기 때문에 사용자 입장에서 훨씬 편하게 스레드를 다룰 수 있습니다. ExecutorService의 인스턴스가 Callable 객체를 인자로 받는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`submit()`</span>을 호출해 Future 인스턴스의 값으로 넘긴 후, 해당 객체가 get()을 호출해 스레드 작업을 수행 후 결과를 받을 수 있습니다.

```java
package java.util.concurrent;

public interface Callable<V> {
    V call() throws Exception;
}
```

## ExecutorService 작업 컬렉션 처리
ExecutorService는 여러 작업을 한 번에 편리하게 처리하는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`invokeAll()`</span>, <span style="color: rgb(3, 150, 150); font-weight: bold;">`invokeAny()`</span> 기능을 제공합니다. invokeAll()은 모든 Callable 작업을 제출하고 모든 작업이 완료될 때까지 대기합니다. 반면 invokeAny()는 모든 작업을 제출한 후 가장 먼저 완료된 작업 하나만 결과를 반환한 후, 완료되지 않은 나머지 작업들은 인터럽트를 통해 취소합니다.

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService es = Executors.newFixedThreadPool(10);

    CallableTask task1 = new CallableTask("task1", 1000);
    CallableTask task2 = new CallableTask("task2", 2000);
    CallableTask task3 = new CallableTask("task3", 3000);

    List<CallableTask> tasks = List.of(task1, task2, task3);

    List<Future<Integer>> futures = es.invokeAll(tasks);

    //invokeAll
    for (Future<Integer> future : futures) {
        Integer value = future.get();
        System.out.printf("value = " + value);
    }
    
    /* invokeAny
    Integer value = es.invokeAny(tasks);
    System.out.printf("value = " + value);
    */

    es.close();
}
```