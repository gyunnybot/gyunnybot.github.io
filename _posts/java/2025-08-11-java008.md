---
layout: single
title:  "문자열 상수 풀과 참조"
folder: "java"
categories:
  - java
permalink: categories/java/8
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

<br><br>

## 문자열 리터럴과 상수 풀
자바에서 문자열을 다루다 보면 `==` 비교가 될 때도 있고 안될 때도 있다. 이 차이를 이해하기 위해선 동일성과 동등성의 차이를 알아야 하며, 그 전에 문자열 상수 풀(String Constant Pool)과 일반 힙 영역 사이의 관계를 먼저 알아야 한다.

JDK 7부터 문자열 리터럴(예: "Hello")은 자바(프로세스) 메모리 구조에서 힙 영역 내 문자열 상수 풀이라는 특별한 곳에 저장된다(본래는 메서드 영역에 존재했다). 동일한 리터럴이 코드에 여러 번 등장하더라도 상수 풀에 단 하나의 정적인 문자열로 존재한다.

아래에서 0x01과 같은 주소 표현은 실제가 아닌 예시일 뿐이며, \'자바 메모리 내 특정 부분에 메모리 주소가 할당되어 데이터가 저장되었다\'라고 이해하면 된다.

```
String a = "Hello"; // 이때 0x01(힙 영역 내 상수 풀)에 "Hello" 저장. a는 0x01의 값을 그대로 참조
String b = "Hello"; // b 또한 0x01의 값을 그대로 참조

문자열 상수 풀 내 0x01 : "Hello" // 동일 문자열에 대해서 상수 풀에 단 하나만 생성된다

a → 0x01
b → 0x01

a == b: true // 같은 주소를 공유하므로 true
a.equals(b): true // 객체 내 값이 같으므로 true
```

<br>
"Hello"는 상수 풀에 한 번만 생성되고, a와 b는 같은 리터럴(같은 참조값)를 공유한다. 그래서 `==` 연산의 결과는 true로 출력된다.

## new String()로 생성된 문자열
한편, new String("Hello")는 상수 풀에 있는 "Hello"를 \'복사\'하여 일반 힙 영역(상수 풀이 아닌 일반적인 인스턴스 저장 영역)에 새로운 String 객체를 만든다.

```
String c = new String("Hello"); // "Hello" 리터럴 복사 후 일반 힙 영역 0x02에 새 객체 생성
String d = "Hello"; // new로 생성되지 않은 d는 0x01의 값을 그대로 참조

문자열 상수 풀 내 0x01 : "Hello" // a에 의해 이미 생성, 주소 할당됨
일반 힙 영역 내 0x02 : "Hello" // c에 의해 새로 생성, 할당됨

c → 0x02
d → 0x01

c == d: false
c.equals(d): true // String은 동등성을 기반으로 equals가 재정의되어 있다
```

<br>
중요한 점은 new String()을 쓰면 무조건 새로운 힙 객체가 생긴다는 것이다. 따라서 new String("Hello")를 여러 번 호출하면 매번 일반 힙 영역에 새로운 객체가 생긴다.

```
String e = new String("Hello"); // "Hello" 리터럴 복사 후 일반 힙 영역 0x03에 새 객체 생성
String f = new String("Hello"); // "Hello" 리터럴 복사 후 일반 힙 영역 0x04에 새 객체 생성

문자열 상수 풀 내 0x01 : "Hello" // a에 의해 이미 생성, 주소 할당됨
일반 힙 영역 내 0x02, 0x03, 0x04 : "Hello" // c, e, f에 의해 새로 생성, 할당됨

e → 0x03
f → 0x04

e == f: false
e.equals(f): true
```

## new String()만 있어도 상수 풀은 생성된다
새로운 힙 객체를 만들 때 \'상수 풀을 참고한다\'는 말은 인스턴스 생성 시 상수 풀의 리터럴을 복사한다는 뜻이다. new String("Hello") 실행 시 JVM은 먼저 상수 풀에서 "Hello" 객체를 찾고, 그 내용을 복사해 힙 객체를 만든다. 즉, 힙 객체를 만드는 데 상수 풀의 값이 재료처럼 사용되는 것이다.

한편, 기존에 생성된 문자열 리터럴 없이 String s1 = new String("Hello");가 프로그램에서 처음 등장하는 경우에도 "Hello"가 상수 풀에 생성된 이후에 일반 힙 영역에서 객체가 값을 복사한 후 생성된다. 다시 말해 리터럴이든 힙 객체든 "Hello"가 코드 영역에 존재하는 그 순간, 컴파일 타임에 상수 풀에 리터럴이 자동으로 생성된 후 절차가 진행된다.

정리하면 상수 풀은 문자열 리터럴의 저장소이고, 힙은 객체의 저장소다. new String()은 상수 풀 내 리터럴을 가져다 복사해서 새 주소를 만든다. 리터럴이 없다면 상수 풀에 우선 생성한 후, 그 값을 복사하여 사용한다. 리터럴은 주소를 공유하고, new 연산은 새 주소를 만든다.

## 동일성과 동등성
`==` 연산은 비교할 대상 a와 b가 정말로 같은 메모리 내 특정 부분을 차지하는지(참조) 물어보는 셈이다. 예를 들어 단순히 리터럴을 동등 연산으로 받았다면, 메서드 영역 내 문자열 상수 풀 어딘가의 참조를 공유하는 것이므로 true를 반환한다. 이것이 동일성이다.

반면 new로 생성된 객체는 다르다. 상수 풀 내 리터럴의 값을 복사해 힙 영역에서 새로운 메모리를 할당 후 저장하는 방식이기 때문에 `==` 연산은 반드시 false를 반환한다. 그러나 똑같은 \'값\'을 상수 풀로부터 받았기 때문에 논리적으로 a와 b는 같은 문자열이다. 따라서 String 타입에서 a.equals(b)는 true를 반환(Object의 equals()를 재정의하여 동등성 비교로 변환)하는데, 이것이 동등성이다. 동등성은 참조의 같음이 아닌, 값의 같음을 확인한다.