---
layout: single
title:  "String 최적화, 익명 클래스"
folder: "java"
categories:
  - java
permalink: categories/java/java002
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## String 최적화
String 클래스는 final로 선언된 byte 타입 배열에 문자열을 저장합니다. 즉, String 클래스를 통해 생성된 문자열은 **불변 객체**입니다. 만약 문자열이 가변이라면, 여러 인스턴스가 같은 문자열 리터럴을 동시에 참조하는 상황에서 값이 변경될 때 <span style="color: rgb(3, 150, 150); font-weight: bold;">`사이드 이펙트(Side Effect)`</span> 문제가 발생하게 될 것입니다.

JAVA에서는 덧셈 연산으로 문자열 합치기가 가능합니다. 하지만 String의 인스턴스는 불변 객체이므로 문자열을 합칠 때마다 매번 새로운 객체를 생성해 변경된 값으로 갱신해야만 합니다. 이는 연산량이 많아질수록 힙 영역에 할당되는 메모리와 GC 횟수가 증가하는 단점이 있습니다.

이를 위해 JAVA는 가변 String 역할을 하는 <span style="color: rgb(3, 150, 150); font-weight: bold;">`StringBuilder`</span> 클래스를 제공합니다. String 타입의 문자열을 합칠 때 내부적으로 StringBuilder 타입의 객체를 생성하여 모든 연산을 수행한 후(append() 메서드를 통한 Method Chaining), 최종적으로 String 타입의 객체로 저장합니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`StringBuffer`</span> 클래스는 StringBuilder와 같은 기능을 수행하지만 StringBuilder와 달리 <span style="color: rgb(3, 150, 150); font-weight: bold;">`동기화`</span>를 지원하는 클래스입니다. 따라서 멀티스레드 상황에서는 안전한 문자열 변경을 위해 StringBuffer를 사용하는 것이 일반적입니다.

## 익명 클래스, 람다 표현식
메서드 내부에 정의된 클래스를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`지역 클래스`</span>라고 합니다. 만약 인터페이스를 구현한 지역 클래스라면 <span style="color: rgb(3, 150, 150); font-weight: bold;">`익명 클래스`</span> 방식으로 클래스 선언과 생성을 한 번에 처리할 수 있습니다.

익명 클래스 방식으로는 **단 한 번만** 인스턴스를 생성할 수 있습니다. 따라서 지역 클래스가 일회성으로 사용되는 경우나 간단한 구현을 제공할 때 사용합니다. 익명 클래스는 인터페이스나 클래스를 즉석에서 받아 구현하는 동시에 이름을 부여하지 않기 때문에 지역 클래스보다 간결하게 코드를 작성할 수 있습니다.

구현할 인터페이스 내부에 **단 하나의 추상 메서드**만 존재한다면 익명 클래스를 <span style="color: rgb(3, 150, 150); font-weight: bold;">`람다 표현식`</span>으로 바꾸어 사용할 수 있습니다.

```java
//인터페이스 Runnable
public interface Runnable {
    void run(); //단 하나의 추상 메서드만 존재
}
```

```java
//지역 클래스
class InnerRunnable implements Runnable {
	@Override
	public void run() {
		System.out.println("Hello from an inner class!");
	}
}

Runnable runnable = new InnerRunnable(); //지역 클래스의 인스턴스 runnable 생성
```

```java
//익명 클래스. 클래스 정의 없이 인터페이스를 즉시 구현함과 동시에 runnable 인스턴스 생성
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello from an anonymous class!");
    }
};
```

```java
//람다 표현식. 인터페이스 내부에 단 하나의 추상 메서드만 존재할 때 구현 가능
Runnable runnable = () -> {
	System.out.println("Hello from a lambda expression!");
}
```