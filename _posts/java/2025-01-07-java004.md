---
layout: single
title:  "제네릭 타입과 메서드"
folder: "java"
categories:
  - java
permalink: categories/java/java004
tags: JAVA
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## 제네릭 타입과 메서드
Object는 모든 클래스의 부모 클래스이므로 손쉽게 다형성을 구현할 수 있다는 장점이 있지만, 자식 타입의 기능을 사용하려면 반드시 다운캐스팅 과정이 필요합니다.

또한 Object 타입으로 기능을 구현하면 개발자가 의도하지 않은 타입이 들어와도 문제가 발생하지 않는다는 단점이 있습니다. 예컨대 Integer와 Double 타입만의 값을 담기 위해 배열을 Object로 생성했지만 String이 들어와도 컴파일 오류는 발생하지 않습니다.

이처럼 Object로 작성된 코드는 다형성을 활용해 중복을 줄이고 코드 재사용을 높일 수는 있으나, 다운 캐스팅을 반드시 진행해야 하며 타입 안정성 또한 떨어집니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`제네릭 타입`</span>은 클래스가 정의되는 시점이 아닌 **인스턴스가 생성되는 시점**에 클래스 타입을 결정합니다. 제네릭 타입은 인스턴스가 생성될 때 타입이 정해지기 때문에 다형성의 장점만을 가지면서 기존의 다운캐스팅 과정에서 발생하는 위험을 미리 차단할 수 있습니다.

<span style="color: rgb(3, 150, 150); font-weight: bold;">`제네릭 메서드`</span>는 클래스 전체가 아닌 **메서드 단위**로 제네릭을 도입할 때 사용됩니다.

요약하면 제네릭 타입은 제네릭을 도입한 클래스를 활용하여 인스턴스를 생성할 때 타입이 결정되고, 제네릭 메서드는 제네릭을 도입한 메서드가 호출될 때 타입이 결정됩니다.

## 와일드 카드
<span style="color: rgb(3, 150, 150); font-weight: bold;">`와일드 카드`</span>는 이미 정의된 제네릭 타입을 일반 메서드의 매개변수로 받을 수 있는 기능입니다.

제네릭 메서드는 타입 매개변수가 존재하며, 호출되는 시점에 타입 매개변수에 인자를 전달받아 타입을 추론 후 결정하는 복잡한 과정을 거칩니다. 또한 제네릭 타입과 메서드가 동시에 사용되면 사용되는 타입 매개변수 간의 혼동을 가져올 수 있습니다.

따라서 제네릭 타입이 이미 정의되어 있으면서 특정 시점에 타입을 변경하는 것이 아니라면 제네릭 메서드가 아닌 와일드 카드를 활용한 메서드를 호출하는 편이 일반적입니다.