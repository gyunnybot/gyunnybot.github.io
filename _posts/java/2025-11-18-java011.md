---
layout: single
title:  "공부하면서 느끼는 Java 기본 보완할 점"
folder: "java"
categories:
  - java
permalink: categories/java/11
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

<br><br>

## 자바가 실행되는 과정
우리가 작성하는 자바 소스 코드 파일(.java)을 바이트코드 클래스 파일(.class)로 변환하는 것을 컴파일(Compile)이라 하고, 이 작업을 javac 컴파일러(쉘/터미널 입장에서는 하나의 명령어)가 담당한다. 터미널에서 javac 명령을 실행하면 해당 작업이 진행된다.

한편 java 명령어(java는 컴파일러가 아니다. 실행 주체는 JVM이기 때문이다)를 실행하면 JVM(자바 가상 머신) 이 시작된다. JVM은 java 명령어가 들어오면 클래스 로딩과 링크(Linking) 과정을 거쳐 메모리에 올린 뒤, 바이트코드를 해석하거나 JIT(Just-In-Time) 컴파일러를 통해 네이티브 코드(CPU가 바로 실행할 수 있는 기계어)로 변환하여 프로그램을 실행한다.

JVM은 운영체제 위에서 동작하는 네이티브 프로그램이기 때문에, 운영체제/CPU 조합마다 다른 JVM(JDK)을 설치해야 한다. 그래서 운영체제별로 배포되는 JDK가 서로 다른 것이다.

흔히 말하는 \'자바를 설치한다\'는 것은 Java SE(Standard Edition)의 구현체인 JDK를 설치한다는 의미이다. JDK에는 javac, java와 같은 개발 도구들과 런타임 환경인 JRE가 포함되어 있으며, JRE 내부에 각종 라이브러리와 JVM이 들어있는 구조다. javac, java는 설치한 jdk 폴더 내 bin에 위치한다.

## 정규 표현식은 암기하는게 좋을까?
정규 표현식은 문자 또는 숫자와 관련된 표현과 반복 기호가 결합된 문자열이다. 보통 Pattern 클래스와 함께 사용해 사용자 입력에 대한 사전 검증을 수행한다. 다만 표현 및 기호에는 여러 가지가 있어서, 이것을 외우는 것에 시간을 쏟기보다는 특정 상황에 필요한 특정 정규 표현식 문자열을 검색 후 가져다 쓰는 것이 더 효율적이라 생각한다. 필요할 때 Pattern.matches(정규 표현식 문자열, 비교할 문자열)로 검증 가능하다는 사실을 떠올리는 것이 더 중요해 보인다.


## 이해가 어려운 람다식 ::
비교적 간단히 이해할 수 있는 람다식은 아래와 같다.

```java
public class LambdaMain {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        list.add("void");
        list.add("public");
        list.add("static");

        list.sort(new Comparator<String>() { // 익명 클래스 활용
            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
        });

        // list.sort((s1,s2) -> s1.compareTo(s2)); 람다식으로 변경

        for (String s : list) {
            System.out.println(s);
        }
    }
}

```

<br>
sort가 가지는 파라미터에 Comparator가 인자로 들어가는 사실을 알고 있고, 해당 클래스 내 메서드가 compare 딱 하나일 때 람다로 치환할 수 있다. \'메서드가 필요로 하는 변수 개수 -> 메서드 본체\'와 같은 형식으로 쓸 수 있다.

놀라운건 특정 인터페이스를 구현하지 않은 클래스라도 변수 형식이 맞으면 대입될 수 있다는 점이다. 아래 코드를 보면, 정적 메서드 staticMethod를 클래스에서 ::를 사용해 호출한다. Computer는 Calculable의 구현체가 아닌데도 불구하고, 내부의 staticMethod가 calc를 재정의한 것으로 간주해 ret을 계산한다.

람다식을 사용하면 코드 생산성은 높아질 수는 있어도, 그에 필요한 규칙을 알고 있어야 한다는 트레이드 오프가 발생하는 것 같다.

```java
@FunctionalInterface
public interface Calculable {
    int calc(int a, int b);
}

public class Person {
    public void action(Calculable calculable) {
        int ret = calculable.calc(10, 4);

        System.out.println("ret = " + ret);
    }
}

public class Computer {
    public static int staticMethod(int a, int b) {
        return a + b;
    }
}

public class LambdaMain {
    public static void main(String[] args) {
        Person person = new Person();

        person.action(Computer::staticMethod); // ret = 14 출력
    }
}
```

## 정렬
래퍼 타입(Wrapper Type)이 아니라, 직접 작성한 클래스 타입의 원소로 이루어진 컬렉션을 정렬하려면 어떻게 해야 할까? 사용자가 만든 객체이기 때문에 정렬을 할 때 두 객체 중에 어떤 객체가 더 큰지 알려줄 방법이 있어야 한다.

해당 클래스가 Comparable 인터페이스를 구현하면 된다. Comparable 내부에는 compareTo() 메서드를 가지고 있어서, 이를 재정의하면 사용자가 만든 클래스 타입의 원소끼리의 비교가 가능하다.

초기에 compareTo()로 이름순 정렬을 수행하도록 재정의했는데, 나이순으로 정렬하고 싶다면 어떻게 해야 할까? 먼저 Comparator 인터페이스의 구현체를 생성한다. 내부의 compare() 메서드를 나이순 정렬로 재정의한 후, Collections.sort()의 두 번째 파라미터에 입력하면 구현한 방식대로 정렬된다. \'compare\'라는 단어가 모두 들어가 혼동될 수 있어, 확실히 알아두는 것이 좋겠다.