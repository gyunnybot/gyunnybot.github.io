---
layout: single
title:  "Java 기본 개념 보강"
folder: "java"
categories:
  - java
permalink: categories/java/11
toc: true
toc_sticky: true
sidebar_main: true
published: true
---

## JAVA, JVM, JDK, JRE
우리가 작성한 자바 소스 코드 파일(.java)을 바이트코드 클래스 파일(.class)로 변환하는 작업을 컴파일(Compile)이라 하고, javac 컴파일러가 담당한다. 터미널에서 javac 명령을 실행하면 컴파일이 진행된다.

이후 java 명령어(컴파일러가 아니다)를 실행하면 JVM(Java Virtual Machine)이 동작한다. JVM은 클래스 파일을 클래스 로더 시스템의 로딩과 링크(Linking) 과정을 거쳐 메모리에 올린 뒤, 실행 엔진 단에서 바이트코드를 해석하거나 JIT(Just-In-Time) 컴파일러를 통해 네이티브 코드(CPU가 바로 실행할 수 있는 기계어)로 변환해 최종적으로 프로그램을 실행한다.

JVM은 결국 운영체제 위에서 동작하는 네이티브 프로그램이기 때문에, 운영체제/CPU 조합마다 다른 JVM(보통 JVM을 포함하는 JDK를 다르게 설치한다)을 설치해야 한다. 그래서 운영체제별로 배포되는 JDK가 서로 다른 것이다.

흔히 말하는 \'Java를 설치한다\'는 것은 Java SE(Standard Edition)의 구현체인 JDK를 설치한다는 의미이다. JDK에는 javac, java와 같은 개발 도구들과 런타임 환경인 JRE가 포함되어 있으며, JRE 내부에는 각종 라이브러리와 JVM이 들어있다. 실제 javac, java는 설치한 jdk 폴더 내 bin에 위치한다.

## 정규 표현식은 암기하는게 좋을까?
정규 표현식은 문자 또는 숫자와 관련된 표현과 반복 기호가 결합된 문자열이다. 다만 표현 및 기호에는 여러 가지가 있어서, 이것을 외우는 것에 시간을 쏟기보다는 특정 상황에 필요한 정규 표현식 문자열을 검색 후 가져다 쓰는 것이 더 효율적일 것이다.

보통 Pattern 클래스와 함께 사용해 사용자 입력에 대한 사전 검증을 수행하므로, 필요할 때 \'Pattern.matches(정규 표현식 문자열, 비교할 문자열)\'로 검증 가능하다는 사실을 떠올리는 것이 더 중요해보인다.

## 메서드 참조 ::
```java
public class LambdaMain {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        list.add("void");
        list.add("static");
        list.add("public");

        // 1. 익명 클래스로 Comparator 구현
        list.sort(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });

       // 2. 람다식으로 Comparator 구현
       list.sort((s1, s2) -> s1.compareTo(s2));

       // 3. 메서드 참조를 통해 Comparator 구현
       list.sort(LambdaMain::staticComparator);

        for (String s : list) {
            System.out.println(s);
        }
    }

    public static int staticComparator(String s1, String s2) {
        return s1.compareTo(s2);
    }
}
```

<br>
sort가 가지는 파라미터에는 Comparator 구현체가 들어가는 사실을 알고 있고, Comparator 인터페이스 내 메서드가 compare 딱 하나(함수형 인터페이스)이므로 람다로 치환할 수 있다. 람다는 \'메서드가 필요로 하는 변수 개수 -> 메서드 본체\'와 같은 형식으로 쓸 수 있다.

람다식을 더 간소화하는 방법으로 메서드를 참조하는 방식이 있다. 임의로 정의한 메서드가 함수형 인터페이스 내 메서드와 비교했을 때 파라미터 형식과 리턴 타입이 맞다면, 이를 대신 사용할 수 있다.

sort로 돌아가보면, `::`를 사용해 클래스 내 static 메서드를 호출하고 있고, 이는 compare 메서드를 구현한다.

메서드 참조에는 4가지 유형이 있다.

    1. 정적 메서드 참조
        설명: 이름 그대로 정적(static) 메서드를 참조한다.
        문법: `클래스명::메서드명`
        예: `Math::max` , `Integer::parseInt` 등
    
    2. 특정 객체의 인스턴스 메서드 참조
        설명: 이름 그대로 특정 객체의 인스턴스 메서드를 참조한다.
        문법: `객체명::인스턴스메서드명`
        예: `person::introduce` , `person::getName` 등
    
    3. 생성자 참조
        설명: 이름 그대로 생성자를 참조한다.
        문법: `클래스명::new`
        예: `Person::new`
    
    4. 임의 객체의 인스턴스 메서드 참조
        설명: 첫 번째 매개변수(또는 해당 람다가 받을 대상)가 그 메서드를 호출하는 객체가 된다.
        문법: `클래스명::인스턴스메서드명`
        예: `Person::introduce` , 같은 람다: `(Person p) -> p.introduce()`

## 정렬
래퍼 타입(Wrapper Type)이 아니라, 직접 작성한 클래스 타입의 원소로 이루어진 컬렉션을 정렬하려면 어떻게 해야 할까? 사용자가 만든 객체이기 때문에 정렬을 할 때 두 객체 중에 어떤 객체가 더 큰지 알려줄 방법이 있어야 한다.

해당 클래스가 Comparable 인터페이스를 구현하면 된다. Comparable 내부에는 compareTo() 메서드를 가지고 있어서, 이를 재정의하면 사용자가 만든 클래스 타입의 원소끼리의 비교가 가능하다.

초기에 compareTo()로 이름순 정렬을 수행하도록 재정의했는데, 나이순으로 정렬하고 싶다면 어떻게 해야 할까? 먼저 Comparator 인터페이스의 구현체를 생성한다. 내부의 compare() 메서드를 나이순 정렬로 재정의한 후, Collections.sort()의 두 번째 파라미터에 입력하면 나이순으로 정렬된다. \'compare\'라는 단어가 모두 들어가기 때문에 확실히 알아두는 편이 좋을 것 같다.